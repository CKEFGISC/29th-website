{"ast":null,"code":"var textarea;\nfunction decodeEntity(name) {\n  textarea = textarea || document.createElement('textarea');\n  textarea.innerHTML = '&' + name + ';';\n  return textarea.value;\n}\n\n/**\n * Utility functions\n */\n\nfunction typeOf(obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isString(obj) {\n  return typeOf(obj) === '[object String]';\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction has(object, key) {\n  return object ? hasOwn.call(object, key) : false;\n}\n\n// Extend objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n  return obj;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) {\n    return str;\n  }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) {\n    return false;\n  }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) {\n    return false;\n  }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {\n    return false;\n  }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) {\n    return false;\n  }\n  if (c === 0x0B) {\n    return false;\n  }\n  if (c >= 0x0E && c <= 0x1F) {\n    return false;\n  }\n  if (c >= 0x7F && c <= 0x9F) {\n    return false;\n  }\n  // out of range\n  if (c > 0x10FFFF) {\n    return false;\n  }\n  return true;\n}\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n      surrogate2 = 0xdc00 + (c & 0x3ff);\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\nvar NAMED_ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n  var decoded = decodeEntity(name);\n  if (name !== decoded) {\n    return decoded;\n  } else if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n  return match;\n}\nfunction replaceEntities(str) {\n  if (str.indexOf('&') < 0) {\n    return str;\n  }\n  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\nvar utils = /*#__PURE__*/Object.freeze({\n  isString: isString,\n  has: has,\n  assign: assign,\n  unescapeMd: unescapeMd,\n  isValidEntityCode: isValidEntityCode,\n  fromCodePoint: fromCodePoint,\n  replaceEntities: replaceEntities,\n  escapeHtml: escapeHtml\n});\n\n/**\n * Renderer rules cache\n */\n\nvar rules = {};\n\n/**\n * Blockquotes\n */\n\nrules.blockquote_open = function /* tokens, idx, options, env */\n() {\n  return '<blockquote>\\n';\n};\nrules.blockquote_close = function (tokens, idx /*, options, env */) {\n  return '</blockquote>' + getBreak(tokens, idx);\n};\n\n/**\n * Code\n */\n\nrules.code = function (tokens, idx /*, options, env */) {\n  if (tokens[idx].block) {\n    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n  }\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\n/**\n * Fenced code blocks\n */\n\nrules.fence = function (tokens, idx, options, env, instance) {\n  var token = tokens[idx];\n  var langClass = '';\n  var langPrefix = options.langPrefix;\n  var langName = '',\n    fences,\n    fenceName;\n  var highlighted;\n  if (token.params) {\n    //\n    // ```foo bar\n    //\n    // Try custom renderer \"foo\" first. That will simplify overwrite\n    // for diagrams, latex, and any other fenced block with custom look\n    //\n\n    fences = token.params.split(/\\s+/g);\n    fenceName = fences.join(' ');\n    if (has(instance.rules.fence_custom, fences[0])) {\n      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\n    }\n    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n    langClass = ' class=\"' + langPrefix + langName + '\"';\n  }\n  if (options.highlight) {\n    highlighted = options.highlight.apply(options.highlight, [token.content].concat(fences)) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n  return '<pre><code' + langClass + '>' + highlighted + '</code></pre>' + getBreak(tokens, idx);\n};\nrules.fence_custom = {};\n\n/**\n * Headings\n */\n\nrules.heading_open = function (tokens, idx /*, options, env */) {\n  return '<h' + tokens[idx].hLevel + '>';\n};\nrules.heading_close = function (tokens, idx /*, options, env */) {\n  return '</h' + tokens[idx].hLevel + '>\\n';\n};\n\n/**\n * Horizontal rules\n */\n\nrules.hr = function (tokens, idx, options /*, env */) {\n  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n};\n\n/**\n * Bullets\n */\n\nrules.bullet_list_open = function /* tokens, idx, options, env */\n() {\n  return '<ul>\\n';\n};\nrules.bullet_list_close = function (tokens, idx /*, options, env */) {\n  return '</ul>' + getBreak(tokens, idx);\n};\n\n/**\n * List items\n */\n\nrules.list_item_open = function /* tokens, idx, options, env */\n() {\n  return '<li>';\n};\nrules.list_item_close = function /* tokens, idx, options, env */\n() {\n  return '</li>\\n';\n};\n\n/**\n * Ordered list items\n */\n\nrules.ordered_list_open = function (tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n  return '<ol' + order + '>\\n';\n};\nrules.ordered_list_close = function (tokens, idx /*, options, env */) {\n  return '</ol>' + getBreak(tokens, idx);\n};\n\n/**\n * Paragraphs\n */\n\nrules.paragraph_open = function (tokens, idx /*, options, env */) {\n  return tokens[idx].tight ? '' : '<p>';\n};\nrules.paragraph_close = function (tokens, idx /*, options, env */) {\n  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n};\n\n/**\n * Links\n */\n\nrules.link_open = function (tokens, idx, options /* env */) {\n  var title = tokens[idx].title ? ' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"' : '';\n  var target = options.linkTarget ? ' target=\"' + options.linkTarget + '\"' : '';\n  return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n};\nrules.link_close = function /* tokens, idx, options, env */\n() {\n  return '</a>';\n};\n\n/**\n * Images\n */\n\nrules.image = function (tokens, idx, options /*, env */) {\n  var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n  var title = tokens[idx].title ? ' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"' : '';\n  var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '\"';\n  var suffix = options.xhtmlOut ? ' /' : '';\n  return '<img' + src + alt + title + suffix + '>';\n};\n\n/**\n * Tables\n */\n\nrules.table_open = function /* tokens, idx, options, env */\n() {\n  return '<table>\\n';\n};\nrules.table_close = function /* tokens, idx, options, env */\n() {\n  return '</table>\\n';\n};\nrules.thead_open = function /* tokens, idx, options, env */\n() {\n  return '<thead>\\n';\n};\nrules.thead_close = function /* tokens, idx, options, env */\n() {\n  return '</thead>\\n';\n};\nrules.tbody_open = function /* tokens, idx, options, env */\n() {\n  return '<tbody>\\n';\n};\nrules.tbody_close = function /* tokens, idx, options, env */\n() {\n  return '</tbody>\\n';\n};\nrules.tr_open = function /* tokens, idx, options, env */\n() {\n  return '<tr>';\n};\nrules.tr_close = function /* tokens, idx, options, env */\n() {\n  return '</tr>\\n';\n};\nrules.th_open = function (tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<th' + (token.align ? ' style=\"text-align:' + token.align + '\"' : '') + '>';\n};\nrules.th_close = function /* tokens, idx, options, env */\n() {\n  return '</th>';\n};\nrules.td_open = function (tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<td' + (token.align ? ' style=\"text-align:' + token.align + '\"' : '') + '>';\n};\nrules.td_close = function /* tokens, idx, options, env */\n() {\n  return '</td>';\n};\n\n/**\n * Bold\n */\n\nrules.strong_open = function /* tokens, idx, options, env */\n() {\n  return '<strong>';\n};\nrules.strong_close = function /* tokens, idx, options, env */\n() {\n  return '</strong>';\n};\n\n/**\n * Italicize\n */\n\nrules.em_open = function /* tokens, idx, options, env */\n() {\n  return '<em>';\n};\nrules.em_close = function /* tokens, idx, options, env */\n() {\n  return '</em>';\n};\n\n/**\n * Strikethrough\n */\n\nrules.del_open = function /* tokens, idx, options, env */\n() {\n  return '<del>';\n};\nrules.del_close = function /* tokens, idx, options, env */\n() {\n  return '</del>';\n};\n\n/**\n * Insert\n */\n\nrules.ins_open = function /* tokens, idx, options, env */\n() {\n  return '<ins>';\n};\nrules.ins_close = function /* tokens, idx, options, env */\n() {\n  return '</ins>';\n};\n\n/**\n * Highlight\n */\n\nrules.mark_open = function /* tokens, idx, options, env */\n() {\n  return '<mark>';\n};\nrules.mark_close = function /* tokens, idx, options, env */\n() {\n  return '</mark>';\n};\n\n/**\n * Super- and sub-script\n */\n\nrules.sub = function (tokens, idx /*, options, env */) {\n  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n};\nrules.sup = function (tokens, idx /*, options, env */) {\n  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n};\n\n/**\n * Breaks\n */\n\nrules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\nrules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\n\n/**\n * Text\n */\n\nrules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n/**\n * Content\n */\n\nrules.htmlblock = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\nrules.htmltag = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * Abbreviations, initialism\n */\n\nrules.abbr_open = function (tokens, idx /*, options, env */) {\n  return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n};\nrules.abbr_close = function /* tokens, idx, options, env */\n() {\n  return '</abbr>';\n};\n\n/**\n * Footnotes\n */\n\nrules.footnote_ref = function (tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n};\nrules.footnote_block_open = function (tokens, idx, options) {\n  var hr = options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n';\n  return hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n};\nrules.footnote_block_close = function () {\n  return '</ol>\\n</section>\\n';\n};\nrules.footnote_open = function (tokens, idx) {\n  var id = Number(tokens[idx].id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n};\nrules.footnote_close = function () {\n  return '</li>\\n';\n};\nrules.footnote_anchor = function (tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n};\n\n/**\n * Definition lists\n */\n\nrules.dl_open = function () {\n  return '<dl>\\n';\n};\nrules.dt_open = function () {\n  return '<dt>';\n};\nrules.dd_open = function () {\n  return '<dd>';\n};\nrules.dl_close = function () {\n  return '</dl>\\n';\n};\nrules.dt_close = function () {\n  return '</dt>\\n';\n};\nrules.dd_close = function () {\n  return '</dd>\\n';\n};\n\n/**\n * Helper functions\n */\n\nfunction nextToken(tokens, idx) {\n  if (++idx >= tokens.length - 2) {\n    return idx;\n  }\n  if (tokens[idx].type === 'paragraph_open' && tokens[idx].tight && tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0 && tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight) {\n    return nextToken(tokens, idx + 2);\n  }\n  return idx;\n}\n\n/**\n * Check to see if `\\n` is needed before the next token.\n *\n * @param  {Array} `tokens`\n * @param  {Number} `idx`\n * @return {String} Empty string or newline\n * @api private\n */\n\nvar getBreak = rules.getBreak = function getBreak(tokens, idx) {\n  idx = nextToken(tokens, idx);\n  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n    return '';\n  }\n  return '\\n';\n};\n\n/**\n * Renderer class. Renders HTML and exposes `rules` to allow\n * local modifications.\n */\n\nfunction Renderer() {\n  this.rules = assign({}, rules);\n\n  // exported helper, for custom rules only\n  this.getBreak = rules.getBreak;\n}\n\n/**\n * Render a string of inline HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length,\n    i = 0;\n  var result = '';\n  while (len--) {\n    result += _rules[tokens[i].type](tokens, i++, options, env, this);\n  }\n  return result;\n};\n\n/**\n * Render a string of HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length,\n    i = -1;\n  var result = '';\n  while (++i < len) {\n    if (tokens[i].type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else {\n      result += _rules[tokens[i].type](tokens, i, options, env, this);\n    }\n  }\n  return result;\n};\n\n/**\n * Ruler is a helper class for building responsibility chains from\n * parse rules. It allows:\n *\n *   - easy stack rules chains\n *   - getting main chain and named chains content (as arrays of functions)\n *\n * Helper methods, should not be used directly.\n * @api private\n */\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // { name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ] }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - digital anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n/**\n * Find the index of a rule by `name`.\n *\n * @param  {String} `name`\n * @return {Number} Index of the given `name`\n * @api private\n */\n\nRuler.prototype.__find__ = function (name) {\n  var len = this.__rules__.length;\n  var i = -1;\n  while (len--) {\n    if (this.__rules__[++i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Build the rules lookup cache\n *\n * @api private\n */\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [''];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n  self.__cache__ = {};\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n/**\n * Ruler public methods\n * ------------------------------------------------\n */\n\n/**\n * Replace rule function\n *\n * @param  {String} `name` Rule name\n * @param  {Function `fn`\n * @param  {Object} `options`\n * @api private\n */\n\nRuler.prototype.at = function (name, fn, options) {\n  var idx = this.__find__(name);\n  var opt = options || {};\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n  this.__rules__[idx].fn = fn;\n  this.__rules__[idx].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain before given the `ruleName`.\n *\n * @param  {String}   `beforeName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var idx = this.__find__(beforeName);\n  var opt = options || {};\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n  this.__rules__.splice(idx, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain after the given `ruleName`.\n *\n * @param  {String}   `afterName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var idx = this.__find__(afterName);\n  var opt = options || {};\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n  this.__rules__.splice(idx + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the end of chain.\n *\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @return {String}\n */\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n  this.__cache__ = null;\n};\n\n/**\n * Enable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to enable\n * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n * @api private\n */\n\nRuler.prototype.enable = function (list, strict) {\n  list = !Array.isArray(list) ? [list] : list;\n\n  // In strict mode disable all existing rules first\n  if (strict) {\n    this.__rules__.forEach(function (rule) {\n      rule.enabled = false;\n    });\n  }\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n  }, this);\n  this.__cache__ = null;\n};\n\n/**\n * Disable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to disable\n * @api private\n */\n\nRuler.prototype.disable = function (list) {\n  list = !Array.isArray(list) ? [list] : list;\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n  }, this);\n  this.__cache__ = null;\n};\n\n/**\n * Get a rules list as an array of functions.\n *\n * @param  {String} `chainName`\n * @return {Object}\n * @api private\n */\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n  return this.__cache__[chainName] || [];\n};\nfunction block(state) {\n  if (state.inlineMode) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.replace(/\\n/g, ' ').trim(),\n      level: 0,\n      lines: [0, 1],\n      children: []\n    });\n  } else {\n    state.block.parse(state.src, state.options, state.env, state.tokens);\n  }\n}\n\n// Inline parser state\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n  this.cache = []; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n  // \"paired\" rules (emphasis, strikes) to not skip\n  // tailing `]`\n\n  this.linkLevel = 0; // Increment for each nesting link. Used to prevent\n  // nesting in definitions\n\n  this.linkContent = ''; // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n  // (backtrack optimization)\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n};\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n  this.cache[key] = val;\n};\n\n// Get cache value\n//\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\nfunction parseLinkLabel(state, start) {\n  var level,\n    found,\n    marker,\n    labelEnd = -1,\n    max = state.posMax,\n    oldPos = state.pos,\n    oldFlag = state.isInLabel;\n  if (state.isInLabel) {\n    return -1;\n  }\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5B /* [ */) {\n      level++;\n    } else if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n    state.parser.skipToken(state);\n  }\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n  return labelEnd;\n}\n\n// Parse abbreviation definitions, i.e. `*[abbr]: description`\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n  if (str.charCodeAt(0) !== 0x2A /* * */) {\n    return -1;\n  }\n  if (str.charCodeAt(1) !== 0x5B /* [ */) {\n    return -1;\n  }\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {\n    return -1;\n  }\n  max = state.posMax;\n\n  // abbr title is always one line, so looking for ending \"\\n\" here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      break;\n    }\n  }\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n  if (title.length === 0) {\n    return -1;\n  }\n  if (!env.abbreviations) {\n    env.abbreviations = {};\n  }\n  // prepend ':' to avoid conflict with Object.prototype members\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n  return pos;\n}\nfunction abbr(state) {\n  var tokens = state.tokens,\n    i,\n    l,\n    content,\n    pos;\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Parse inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' && tokens[i].type === 'inline' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n        if (pos < 0) {\n          break;\n        }\n        content = content.slice(pos).trim();\n      }\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\nfunction normalizeLink(url) {\n  var normalized = replaceEntities(url);\n  // We shouldn't care about the result of malformed URIs,\n  // and should not throw an exception.\n  try {\n    normalized = decodeURI(normalized);\n  } catch (err) {}\n  return encodeURI(normalized);\n}\n\n/**\n * Parse link destination\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkDestination(state, pos) {\n  var code,\n    level,\n    link,\n    start = pos,\n    max = state.posMax;\n  if (state.src.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = state.src.charCodeAt(pos);\n      if (code === 0x0A /* \\n */) {\n        return false;\n      }\n      if (code === 0x3E /* > */) {\n        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n        if (!state.parser.validateLink(link)) {\n          return false;\n        }\n        state.pos = pos + 1;\n        state.linkContent = link;\n        return true;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n      pos++;\n    }\n\n    // no closing '>'\n    return false;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n    if (code === 0x20) {\n      break;\n    }\n\n    // ascii control chars\n    if (code < 0x20 || code === 0x7F) {\n      break;\n    }\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n    if (code === 0x28 /* ( */) {\n      level++;\n      if (level > 1) {\n        break;\n      }\n    }\n    if (code === 0x29 /* ) */) {\n      level--;\n      if (level < 0) {\n        break;\n      }\n    }\n    pos++;\n  }\n  if (start === pos) {\n    return false;\n  }\n  link = unescapeMd(state.src.slice(start, pos));\n  if (!state.parser.validateLink(link)) {\n    return false;\n  }\n  state.linkContent = link;\n  state.pos = pos;\n  return true;\n}\n\n/**\n * Parse link title\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkTitle(state, pos) {\n  var code,\n    start = pos,\n    max = state.posMax,\n    marker = state.src.charCodeAt(pos);\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {\n    return false;\n  }\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) {\n    marker = 0x29;\n  }\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n    if (code === marker) {\n      state.pos = pos + 1;\n      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n      return true;\n    }\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n    pos++;\n  }\n  return false;\n}\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n  if (str.charCodeAt(0) !== 0x5B /* [ */) {\n    return -1;\n  }\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {\n    return -1;\n  }\n  max = state.posMax;\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  if (!parseLinkDestination(state, pos)) {\n    return -1;\n  }\n  href = state.linkContent;\n  pos = state.pos;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  }\n\n  // ensure that the end of the line is empty\n  while (pos < max && state.src.charCodeAt(pos) === 0x20 /* space */) {\n    pos++;\n  }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) {\n    return -1;\n  }\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n  return pos;\n}\nfunction references(state) {\n  var tokens = state.tokens,\n    i,\n    l,\n    content,\n    pos;\n  state.env.references = state.env.references || {};\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Scan definitions in paragraph inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' && tokens[i - 1].type === 'paragraph_open' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n        if (pos < 0) {\n          break;\n        }\n        content = content.slice(pos).trim();\n      }\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\nfunction inline(state) {\n  var tokens = state.tokens,\n    tok,\n    i,\n    l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.inline.parse(tok.content, state.options, state.env, tok.children);\n    }\n  }\n}\nfunction footnote_block(state) {\n  var i,\n    l,\n    j,\n    t,\n    lastParagraph,\n    list,\n    tokens,\n    current,\n    currentLabel,\n    level = 0,\n    insideRef = false,\n    refTokens = {};\n  if (!state.env.footnotes) {\n    return;\n  }\n  state.tokens = state.tokens.filter(function (tok) {\n    if (tok.type === 'footnote_reference_open') {\n      insideRef = true;\n      current = [];\n      currentLabel = tok.label;\n      return false;\n    }\n    if (tok.type === 'footnote_reference_close') {\n      insideRef = false;\n      // prepend ':' to avoid conflict with Object.prototype members\n      refTokens[':' + currentLabel] = current;\n      return false;\n    }\n    if (insideRef) {\n      current.push(tok);\n    }\n    return !insideRef;\n  });\n  if (!state.env.footnotes.list) {\n    return;\n  }\n  list = state.env.footnotes.list;\n  state.tokens.push({\n    type: 'footnote_block_open',\n    level: level++\n  });\n  for (i = 0, l = list.length; i < l; i++) {\n    state.tokens.push({\n      type: 'footnote_open',\n      id: i,\n      level: level++\n    });\n    if (list[i].tokens) {\n      tokens = [];\n      tokens.push({\n        type: 'paragraph_open',\n        tight: false,\n        level: level++\n      });\n      tokens.push({\n        type: 'inline',\n        content: '',\n        level: level,\n        children: list[i].tokens\n      });\n      tokens.push({\n        type: 'paragraph_close',\n        tight: false,\n        level: --level\n      });\n    } else if (list[i].label) {\n      tokens = refTokens[':' + list[i].label];\n    }\n    state.tokens = state.tokens.concat(tokens);\n    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n      lastParagraph = state.tokens.pop();\n    } else {\n      lastParagraph = null;\n    }\n    t = list[i].count > 0 ? list[i].count : 1;\n    for (j = 0; j < t; j++) {\n      state.tokens.push({\n        type: 'footnote_anchor',\n        id: i,\n        subId: j,\n        level: level\n      });\n    }\n    if (lastParagraph) {\n      state.tokens.push(lastParagraph);\n    }\n    state.tokens.push({\n      type: 'footnote_close',\n      level: --level\n    });\n  }\n  state.tokens.push({\n    type: 'footnote_block_close',\n    level: --level\n  });\n}\n\n// Enclose abbreviations in <abbr> tags\n//\n\nvar PUNCT_CHARS = ' \\n()[]\\'\".,!?-';\n\n// from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\nfunction regEscape(s) {\n  return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n}\nfunction abbr2(state) {\n  var i,\n    j,\n    l,\n    tokens,\n    token,\n    text,\n    nodes,\n    pos,\n    level,\n    reg,\n    m,\n    regText,\n    blockTokens = state.tokens;\n  if (!state.env.abbreviations) {\n    return;\n  }\n  if (!state.env.abbrRegExp) {\n    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])' + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n      return x.substr(1);\n    }).sort(function (a, b) {\n      return b.length - a.length;\n    }).map(regEscape).join('|') + ')' + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n    state.env.abbrRegExp = new RegExp(regText, 'g');\n  }\n  reg = state.env.abbrRegExp;\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n    tokens = blockTokens[j].children;\n\n    // We scan from the end, to keep position when new tags added.\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n      if (token.type !== 'text') {\n        continue;\n      }\n      pos = 0;\n      text = token.content;\n      reg.lastIndex = 0;\n      level = token.level;\n      nodes = [];\n      while (m = reg.exec(text)) {\n        if (reg.lastIndex > pos) {\n          nodes.push({\n            type: 'text',\n            content: text.slice(pos, m.index + m[1].length),\n            level: level\n          });\n        }\n        nodes.push({\n          type: 'abbr_open',\n          title: state.env.abbreviations[':' + m[2]],\n          level: level++\n        });\n        nodes.push({\n          type: 'text',\n          content: m[2],\n          level: level\n        });\n        nodes.push({\n          type: 'abbr_close',\n          level: --level\n        });\n        pos = reg.lastIndex - m[3].length;\n      }\n      if (!nodes.length) {\n        continue;\n      }\n      if (pos < text.length) {\n        nodes.push({\n          type: 'text',\n          content: text.slice(pos),\n          level: level\n        });\n      }\n\n      // replace current node\n      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n    }\n  }\n}\n\n// Simple typographical replacements\n//\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '©',\n  'r': '®',\n  'p': '§',\n  'tm': '™'\n};\nfunction replaceScopedAbbr(str) {\n  if (str.indexOf('(') < 0) {\n    return str;\n  }\n  return str.replace(SCOPED_ABBR_RE, function (match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  });\n}\nfunction replace(state) {\n  var i, token, text, inlineTokens, blkIdx;\n  if (!state.options.typographer) {\n    return;\n  }\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') {\n      continue;\n    }\n    inlineTokens = state.tokens[blkIdx].children;\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n      if (token.type === 'text') {\n        text = token.content;\n        text = replaceScopedAbbr(text);\n        if (RARE_RE.test(text)) {\n          text = text.replace(/\\+-/g, '±')\n          // .., ..., ....... -> …\n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n          // em-dash\n          .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n          // en-dash\n          .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2').replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n        }\n        token.content = text;\n      }\n    }\n  }\n}\n\n// Convert straight quotation marks to typographic ones\n//\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar PUNCT_RE = /[-\\s()\\[\\]]/;\nvar APOSTROPHE = '’';\n\n// This function returns true if the character at `pos`\n// could be inside a word.\nfunction isLetter(str, pos) {\n  if (pos < 0 || pos >= str.length) {\n    return false;\n  }\n  return !PUNCT_RE.test(str[pos]);\n}\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\nfunction smartquotes(state) {\n  /*eslint max-depth:0*/\n  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j, isSingle, blkIdx, tokens, stack;\n  if (!state.options.typographer) {\n    return;\n  }\n  stack = [];\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') {\n      continue;\n    }\n    tokens = state.tokens[blkIdx].children;\n    stack.length = 0;\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) {\n        continue;\n      }\n      thisLevel = tokens[i].level;\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) {\n          break;\n        }\n      }\n      stack.length = j + 1;\n      text = token.content;\n      pos = 0;\n      max = text.length;\n\n      /*eslint no-labels:0,block-scoped-var:0*/\n      OUTER: while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n        if (!t) {\n          break;\n        }\n        lastSpace = !isLetter(text, t.index - 1);\n        pos = t.index + 1;\n        isSingle = t[0] === \"'\";\n        nextSpace = !isLetter(text, pos);\n        if (!nextSpace && !lastSpace) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n          continue;\n        }\n        canOpen = !nextSpace;\n        canClose = !lastSpace;\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n            if (stack[j].level < thisLevel) {\n              break;\n            }\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n              if (isSingle) {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n              } else {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n              }\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Core parser `rules`\n */\n\nvar _rules = [['block', block], ['abbr', abbr], ['references', references], ['inline', inline], ['footnote_tail', footnote_block], ['abbr2', abbr2], ['replacements', replace], ['smartquotes', smartquotes]];\n\n/**\n * Class for top level (`core`) parser rules\n *\n * @api private\n */\n\nfunction Core() {\n  this.options = {};\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n/**\n * Process rules with the given `state`\n *\n * @param  {Object} `state`\n * @api private\n */\n\nCore.prototype.process = function (state) {\n  var i, l, rules;\n  rules = this.ruler.getRules('');\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\n// Parser state class\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n  this.src = src;\n\n  // Shortcuts to simplify nested calls\n  this.parser = parser;\n  this.options = options;\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n  this.eMarks = []; // line end offsets for fast jumps\n  this.tShift = []; // indent for each line\n\n  // block parser variables\n  this.blkIndent = 0; // required block content indent\n  // (for example, if we are in list)\n  this.line = 0; // line index in src\n  this.lineMax = 0; // lines count\n  this.tight = false; // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n    if (!indent_found) {\n      if (ch === 0x20 /* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20 /* space */) {\n      break;\n    }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n    first,\n    last,\n    queue,\n    shift,\n    line = begin;\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n  queue = new Array(end - begin);\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) {\n      shift = indent;\n    }\n    if (shift < 0) {\n      shift = 0;\n    }\n    first = this.bMarks[line] + shift;\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n    queue[i] = this.src.slice(first, last);\n  }\n  return queue.join('');\n};\n\n// Code block (4 spaces padded)\n\nfunction code(state, startLine, endLine /*, silent*/) {\n  var nextLine, last;\n  if (state.tShift[startLine] - state.blkIndent < 4) {\n    return false;\n  }\n  last = nextLine = startLine + 1;\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'code',\n    content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n    block: true,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n}\n\n// fences (``` lang, ~~~ lang)\n\nfunction fences(state, startLine, endLine, silent) {\n  var marker,\n    len,\n    params,\n    nextLine,\n    mem,\n    haveEndMarker = false,\n    pos = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine];\n  if (pos + 3 > max) {\n    return false;\n  }\n  marker = state.src.charCodeAt(pos);\n  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n  len = pos - mem;\n  if (len < 3) {\n    return false;\n  }\n  params = state.src.slice(pos, max).trim();\n  if (params.indexOf('`') >= 0) {\n    return false;\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true;\n  }\n\n  // search end of block\n  nextLine = startLine;\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue;\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n    if (pos < max) {\n      continue;\n    }\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.tShift[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n}\n\n// Block quotes\n\nfunction blockquote(state, startLine, endLine, silent) {\n  var nextLine,\n    lastLineEmpty,\n    oldTShift,\n    oldBMarks,\n    oldIndent,\n    oldParentType,\n    lines,\n    terminatorRules,\n    i,\n    l,\n    terminate,\n    pos = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine];\n  if (pos > max) {\n    return false;\n  }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) {\n    return true;\n  }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n    if (state.src.charCodeAt(pos++) === 0x3E /* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) {\n        pos++;\n      }\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) {\n      break;\n    }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [startLine, 0],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n  return true;\n}\n\n// Horizontal rule\n\nfunction hr(state, startLine, endLine, silent) {\n  var marker,\n    cnt,\n    ch,\n    pos = state.bMarks[startLine],\n    max = state.eMarks[startLine];\n  pos += state.tShift[startLine];\n  if (pos > max) {\n    return false;\n  }\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 one\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && ch !== 0x20 /* space */) {\n      return false;\n    }\n    if (ch === marker) {\n      cnt++;\n    }\n  }\n  if (cnt < 3) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'hr',\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n}\n\n// Lists\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n  if (pos >= max) {\n    return -1;\n  }\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {\n    return -1;\n  }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n    pos = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine];\n  if (pos + 1 >= max) {\n    return -1;\n  }\n  ch = state.src.charCodeAt(pos++);\n  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {\n    return -1;\n  }\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n    ch = state.src.charCodeAt(pos++);\n    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {\n      break;\n    }\n    return -1;\n  }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20 /* space */) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\nfunction markTightParagraphs(state, idx) {\n  var i,\n    l,\n    level = state.level + 2;\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\nfunction list(state, startLine, endLine, silent) {\n  var nextLine,\n    indent,\n    oldTShift,\n    oldIndent,\n    oldTight,\n    oldParentType,\n    start,\n    posAfterMarker,\n    max,\n    indentAfterMarker,\n    markerValue,\n    markerCharCode,\n    isOrdered,\n    contentStart,\n    listTokIdx,\n    prevEmptyEnd,\n    listLines,\n    itemLines,\n    tight = true,\n    terminatorRules,\n    i,\n    l,\n    terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) {\n    return true;\n  }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  }\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    }\n\n    // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n    if (indentAfterMarker < 1) {\n      indentAfterMarker = 1;\n    }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker;\n\n    // Run subparser & write tokens\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [startLine, 0],\n      level: state.level++\n    });\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n    state.parser.tokenize(state, startLine, endLine, true);\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n    if (nextLine >= endLine) {\n      break;\n    }\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n  return true;\n}\n\n// Process footnote reference list\n\nfunction footnote(state, startLine, endLine, silent) {\n  var oldBMark,\n    oldTShift,\n    oldParentType,\n    pos,\n    label,\n    start = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine];\n\n  // line should be at least 5 chars - \"[^x]:\"\n  if (start + 4 > max) {\n    return false;\n  }\n  if (state.src.charCodeAt(start) !== 0x5B /* [ */) {\n    return false;\n  }\n  if (state.src.charCodeAt(start + 1) !== 0x5E /* ^ */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) {\n      return false;\n    }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n  if (pos === start + 2) {\n    return false;\n  } // no empty footnote labels\n  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  pos++;\n  if (!state.env.footnotes) {\n    state.env.footnotes = {};\n  }\n  if (!state.env.footnotes.refs) {\n    state.env.footnotes.refs = {};\n  }\n  label = state.src.slice(start + 2, pos - 2);\n  state.env.footnotes.refs[':' + label] = -1;\n  state.tokens.push({\n    type: 'footnote_reference_open',\n    label: label,\n    level: state.level++\n  });\n  oldBMark = state.bMarks[startLine];\n  oldTShift = state.tShift[startLine];\n  oldParentType = state.parentType;\n  state.tShift[startLine] = state.skipSpaces(pos) - pos;\n  state.bMarks[startLine] = pos;\n  state.blkIndent += 4;\n  state.parentType = 'footnote';\n  if (state.tShift[startLine] < state.blkIndent) {\n    state.tShift[startLine] += state.blkIndent;\n    state.bMarks[startLine] -= state.blkIndent;\n  }\n  state.parser.tokenize(state, startLine, endLine, true);\n  state.parentType = oldParentType;\n  state.blkIndent -= 4;\n  state.tShift[startLine] = oldTShift;\n  state.bMarks[startLine] = oldBMark;\n  state.tokens.push({\n    type: 'footnote_reference_close',\n    level: --state.level\n  });\n  return true;\n}\n\n// heading (#, ##, ...)\n\nfunction heading(state, startLine, endLine, silent) {\n  var ch,\n    level,\n    tmp,\n    pos = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine];\n  if (pos >= max) {\n    return false;\n  }\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x23 /* # */ || pos >= max) {\n    return false;\n  }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23 /* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n  if (level > 6 || pos < max && ch !== 0x20 /* space */) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipCharsBack(max, 0x20, pos); // space\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20 /* space */) {\n    max = tmp;\n  }\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: level,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n\n  // only if header is not empty\n  if (pos < max) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.slice(pos, max).trim(),\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n  }\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: level,\n    level: state.level\n  });\n  return true;\n}\n\n// lheading (---, ===)\n\nfunction lheading(state, startLine, endLine /*, silent*/) {\n  var marker,\n    pos,\n    max,\n    next = startLine + 1;\n  if (next >= endLine) {\n    return false;\n  }\n  if (state.tShift[next] < state.blkIndent) {\n    return false;\n  }\n\n  // Scan next line\n\n  if (state.tShift[next] - state.blkIndent > 3) {\n    return false;\n  }\n  pos = state.bMarks[next] + state.tShift[next];\n  max = state.eMarks[next];\n  if (pos >= max) {\n    return false;\n  }\n  marker = state.src.charCodeAt(pos);\n  if (marker !== 0x2D /* - */ && marker !== 0x3D /* = */) {\n    return false;\n  }\n  pos = state.skipChars(pos, marker);\n  pos = state.skipSpaces(pos);\n  if (pos < max) {\n    return false;\n  }\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  state.line = next + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: marker === 0x3D /* = */ ? 1 : 2,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  state.tokens.push({\n    type: 'inline',\n    content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n    level: state.level + 1,\n    lines: [startLine, state.line - 1],\n    children: []\n  });\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: marker === 0x3D /* = */ ? 1 : 2,\n    level: state.level\n  });\n  return true;\n}\n\n// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\nvar html_blocks = {};\n['article', 'aside', 'button', 'blockquote', 'body', 'canvas', 'caption', 'col', 'colgroup', 'dd', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'iframe', 'li', 'map', 'object', 'ol', 'output', 'p', 'pre', 'progress', 'script', 'section', 'style', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'tr', 'thead', 'ul', 'video'].forEach(function (name) {\n  html_blocks[name] = true;\n});\n\n// HTML block\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\nfunction isLetter$1(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;\n}\nfunction htmlblock(state, startLine, endLine, silent) {\n  var ch,\n    match,\n    nextLine,\n    pos = state.bMarks[startLine],\n    max = state.eMarks[startLine],\n    shift = state.tShift[startLine];\n  pos += shift;\n  if (!state.options.html) {\n    return false;\n  }\n  if (shift > 3 || pos + 2 >= max) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {\n    return false;\n  }\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch === 0x21 /* ! */ || ch === 0x3F /* ? */) {\n    // Directive start / comment start / processing instruction start\n    if (silent) {\n      return true;\n    }\n  } else if (ch === 0x2F /* / */ || isLetter$1(ch)) {\n    // Probably start or end of tag\n    if (ch === 0x2F /* \\ */) {\n      // closing tag\n      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n      if (!match) {\n        return false;\n      }\n    } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n      if (!match) {\n        return false;\n      }\n    }\n    // Make sure tag name is valid\n    if (html_blocks[match[1].toLowerCase()] !== true) {\n      return false;\n    }\n    if (silent) {\n      return true;\n    }\n  } else {\n    return false;\n  }\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n  nextLine = startLine + 1;\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [startLine, state.line],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n  return true;\n}\n\n// GFM table, non-standard\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n    max = state.eMarks[line];\n  return state.src.substr(pos, max - pos);\n}\nfunction table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines;\n\n  // should have at least three lines\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n  nextLine = startLine + 1;\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  // first character of the second line should be '|' or '-'\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {\n    return false;\n  }\n  lineText = getLine(state, startLine + 1);\n  if (!/^[-:| ]+$/.test(lineText)) {\n    return false;\n  }\n  rows = lineText.split('|');\n  if (rows <= 2) {\n    return false;\n  }\n  aligns = [];\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A /* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n  if (aligns.length !== rows.length) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [startLine, 0],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [startLine, startLine + 1],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [startLine, startLine + 1],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({\n      type: 'th_close',\n      level: --state.level\n    });\n  }\n  state.tokens.push({\n    type: 'tr_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'thead_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [startLine + 2, 0],\n    level: state.level++\n  });\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    }\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) {\n      break;\n    }\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n    state.tokens.push({\n      type: 'tr_open',\n      level: state.level++\n    });\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({\n        type: 'td_open',\n        align: aligns[i],\n        level: state.level++\n      });\n      // 0x7c === '|'\n      cell = rows[i].substring(rows[i].charCodeAt(0) === 0x7c ? 1 : 0, rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({\n        type: 'td_close',\n        level: --state.level\n      });\n    }\n    state.tokens.push({\n      type: 'tr_close',\n      level: --state.level\n    });\n  }\n  state.tokens.push({\n    type: 'tbody_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'table_close',\n    level: --state.level\n  });\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n}\n\n// Definition lists\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos,\n    marker,\n    start = state.bMarks[line] + state.tShift[line],\n    max = state.eMarks[line];\n  if (start >= max) {\n    return -1;\n  }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E /* ~ */ && marker !== 0x3A /* : */) {\n    return -1;\n  }\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) {\n    return -1;\n  }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) {\n    return -1;\n  }\n  return pos;\n}\nfunction markTightParagraphs$1(state, idx) {\n  var i,\n    l,\n    level = state.level + 2;\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\nfunction deflist(state, startLine, endLine, silent) {\n  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) {\n      return false;\n    }\n    return skipMarker(state, startLine) >= 0;\n  }\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) {\n      return false;\n    }\n  }\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [startLine, 0],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER: for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [dtLine, dtLine],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [dtLine, dtLine],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [nextLine, 0],\n        level: state.level++\n      });\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n      itemLines[1] = nextLine = state.line;\n      if (nextLine >= endLine) {\n        break OUTER;\n      }\n      if (state.tShift[nextLine] < state.blkIndent) {\n        break OUTER;\n      }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) {\n        break;\n      }\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n    if (nextLine >= endLine) {\n      break;\n    }\n    dtLine = nextLine;\n    if (state.isEmpty(dtLine)) {\n      break;\n    }\n    if (state.tShift[dtLine] < state.blkIndent) {\n      break;\n    }\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) {\n      break;\n    }\n    if (state.isEmpty(ddLine)) {\n      ddLine++;\n    }\n    if (ddLine >= endLine) {\n      break;\n    }\n    if (state.tShift[ddLine] < state.blkIndent) {\n      break;\n    }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) {\n      break;\n    }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs$1(state, listTokIdx);\n  }\n  return true;\n}\n\n// Paragraph\n\nfunction paragraph(state, startLine /*, endLine*/) {\n  var endLine,\n    content,\n    terminate,\n    i,\n    l,\n    nextLine = startLine + 1,\n    terminatorRules;\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) {\n        continue;\n      }\n\n      // Some tags can terminate paragraph without empty line.\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        break;\n      }\n    }\n  }\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [startLine, state.line],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n  return true;\n}\n\n/**\n * Parser rules\n */\n\nvar _rules$1 = [['code', code], ['fences', fences, ['paragraph', 'blockquote', 'list']], ['blockquote', blockquote, ['paragraph', 'blockquote', 'list']], ['hr', hr, ['paragraph', 'blockquote', 'list']], ['list', list, ['paragraph', 'blockquote']], ['footnote', footnote, ['paragraph']], ['heading', heading, ['paragraph', 'blockquote']], ['lheading', lheading], ['htmlblock', htmlblock, ['paragraph', 'blockquote']], ['table', table, ['paragraph']], ['deflist', deflist, ['paragraph']], ['paragraph', paragraph]];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n      alt: (_rules$1[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n    line = state.line;\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {\n        break;\n      }\n      state.line = line;\n    }\n  }\n};\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state,\n    lineStart = 0,\n    lastTabPos = 0;\n  if (!str) {\n    return [];\n  }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A /* \\n */:\n    case 0x5C /* \\ */:\n    case 0x60 /* ` */:\n    case 0x2A /* * */:\n    case 0x5F /* _ */:\n    case 0x5E /* ^ */:\n    case 0x5B /* [ */:\n    case 0x5D /* ] */:\n    case 0x21 /* ! */:\n    case 0x26 /* & */:\n    case 0x3C /* < */:\n    case 0x3E /* > */:\n    case 0x7B /* { */:\n    case 0x7D /* } */:\n    case 0x24 /* $ */:\n    case 0x25 /* % */:\n    case 0x40 /* @ */:\n    case 0x7E /* ~ */:\n    case 0x2B /* + */:\n    case 0x3D /* = */:\n    case 0x3A /* : */:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction text(state, silent) {\n  var pos = state.pos;\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n  if (pos === state.pos) {\n    return false;\n  }\n  if (!silent) {\n    state.pending += state.src.slice(state.pos, pos);\n  }\n  state.pos = pos;\n  return true;\n}\n\n// Proceess '\\n'\n\nfunction newline(state, silent) {\n  var pmax,\n    max,\n    pos = state.pos;\n  if (state.src.charCodeAt(pos) !== 0x0A /* \\n */) {\n    return false;\n  }\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Strip out all trailing spaces on this line.\n        for (var i = pmax - 2; i >= 0; i--) {\n          if (state.pending.charCodeAt(i) !== 0x20) {\n            state.pending = state.pending.substring(0, i + 1);\n            break;\n          }\n        }\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push({\n          type: 'softbreak',\n          level: state.level\n        });\n      }\n    } else {\n      state.push({\n        type: 'softbreak',\n        level: state.level\n      });\n    }\n  }\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n  state.pos = pos;\n  return true;\n}\n\n// Proceess escaped chars and hardbreaks\n\nvar ESCAPED = [];\nfor (var i = 0; i < 256; i++) {\n  ESCAPED.push(0);\n}\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {\n  ESCAPED[ch.charCodeAt(0)] = 1;\n});\nfunction escape(state, silent) {\n  var ch,\n    pos = state.pos,\n    max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x5C /* \\ */) {\n    return false;\n  }\n  pos++;\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) {\n        state.pending += state.src[pos];\n      }\n      state.pos += 2;\n      return true;\n    }\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      }\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n        pos++;\n      }\n      state.pos = pos;\n      return true;\n    }\n  }\n  if (!silent) {\n    state.pending += '\\\\';\n  }\n  state.pos++;\n  return true;\n}\n\n// Parse backticks\n\nfunction backticks(state, silent) {\n  var start,\n    max,\n    marker,\n    matchStart,\n    matchEnd,\n    pos = state.pos,\n    ch = state.src.charCodeAt(pos);\n  if (ch !== 0x60 /* ` */) {\n    return false;\n  }\n  start = pos;\n  pos++;\n  max = state.posMax;\n  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {\n    pos++;\n  }\n  marker = state.src.slice(start, pos);\n  matchStart = matchEnd = pos;\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {\n      matchEnd++;\n    }\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        state.push({\n          type: 'code',\n          content: state.src.slice(pos, matchStart).replace(/[ \\n]+/g, ' ').trim(),\n          block: false,\n          level: state.level\n        });\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n  if (!silent) {\n    state.pending += marker;\n  }\n  state.pos += marker.length;\n  return true;\n}\n\n// Process ~~deleted text~~\n\nfunction del(state, silent) {\n  var found,\n    pos,\n    stack,\n    max = state.posMax,\n    start = state.pos,\n    lastChar,\n    nextChar;\n  if (state.src.charCodeAt(start) !== 0x7E /* ~ */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n  if (start + 4 >= max) {\n    return false;\n  }\n  if (state.src.charCodeAt(start + 1) !== 0x7E /* ~ */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n  if (lastChar === 0x7E /* ~ */) {\n    return false;\n  }\n  if (nextChar === 0x7E /* ~ */) {\n    return false;\n  }\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x7E /* ~ */) {\n    pos++;\n  }\n  if (pos > start + 3) {\n    // sequence of 4+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n    return true;\n  }\n  state.pos = start + 2;\n  stack = 1;\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E /* ~ */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x7E /* ~ */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x7E /* ~ */ && lastChar !== 0x7E /* ~ */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '~~'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '~~'\n            stack++;\n          } // else {\n          //  // standalone ' ~~ ' indented with spaces\n          // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n    state.parser.skipToken(state);\n  }\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n  if (!silent) {\n    state.push({\n      type: 'del_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'del_close',\n      level: --state.level\n    });\n  }\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ++inserted text++\n\nfunction ins(state, silent) {\n  var found,\n    pos,\n    stack,\n    max = state.posMax,\n    start = state.pos,\n    lastChar,\n    nextChar;\n  if (state.src.charCodeAt(start) !== 0x2B /* + */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n  if (start + 4 >= max) {\n    return false;\n  }\n  if (state.src.charCodeAt(start + 1) !== 0x2B /* + */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n  if (lastChar === 0x2B /* + */) {\n    return false;\n  }\n  if (nextChar === 0x2B /* + */) {\n    return false;\n  }\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B /* + */) {\n    pos++;\n  }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n    return true;\n  }\n  state.pos = start + 2;\n  stack = 1;\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B /* + */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x2B /* + */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x2B /* + */ && lastChar !== 0x2B /* + */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '++'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '++'\n            stack++;\n          } // else {\n          //  // standalone ' ++ ' indented with spaces\n          // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n    state.parser.skipToken(state);\n  }\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n  if (!silent) {\n    state.push({\n      type: 'ins_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'ins_close',\n      level: --state.level\n    });\n  }\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ==highlighted text==\n\nfunction mark(state, silent) {\n  var found,\n    pos,\n    stack,\n    max = state.posMax,\n    start = state.pos,\n    lastChar,\n    nextChar;\n  if (state.src.charCodeAt(start) !== 0x3D /* = */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n  if (start + 4 >= max) {\n    return false;\n  }\n  if (state.src.charCodeAt(start + 1) !== 0x3D /* = */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n  if (lastChar === 0x3D /* = */) {\n    return false;\n  }\n  if (nextChar === 0x3D /* = */) {\n    return false;\n  }\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x3D /* = */) {\n    pos++;\n  }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n    return true;\n  }\n  state.pos = start + 2;\n  stack = 1;\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x3D /* = */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x3D /* = */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x3D /* = */ && lastChar !== 0x3D /* = */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '=='\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '=='\n            stack++;\n          } // else {\n          //  // standalone ' == ' indented with spaces\n          // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n    state.parser.skipToken(state);\n  }\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n  if (!silent) {\n    state.push({\n      type: 'mark_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'mark_close',\n      level: --state.level\n    });\n  }\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process *this* and _that_\n\nfunction isAlphaNum(code) {\n  return code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */ || code >= 0x41 /* A */ && code <= 0x5A /* Z */ || code >= 0x61 /* a */ && code <= 0x7A /* z */;\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start,\n    lastChar,\n    nextChar,\n    count,\n    can_open = true,\n    can_close = true,\n    max = state.posMax,\n    marker = state.src.charCodeAt(start);\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n  if (pos >= max) {\n    can_open = false;\n  }\n  count = pos - start;\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) {\n      can_open = false;\n    }\n    if (lastChar === 0x20 || lastChar === 0x0A) {\n      can_close = false;\n    }\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) {\n        can_open = false;\n      }\n      if (isAlphaNum(nextChar)) {\n        can_close = false;\n      }\n    }\n  }\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\nfunction emphasis(state, silent) {\n  var startCount,\n    count,\n    found,\n    oldCount,\n    newCount,\n    stack,\n    res,\n    max = state.posMax,\n    start = state.pos,\n    marker = state.src.charCodeAt(start);\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) {\n      state.pending += state.src.slice(start, state.pos);\n    }\n    return true;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  state.pos = start + startCount;\n  stack = [startCount];\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n          if (stack.length === 0) {\n            break;\n          }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n      if (res.can_open) {\n        stack.push(count);\n      }\n      state.pos += count;\n      continue;\n    }\n    state.parser.skipToken(state);\n  }\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_open',\n        level: state.level++\n      });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_open',\n        level: state.level++\n      });\n    }\n    state.parser.tokenize(state);\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_close',\n        level: --state.level\n      });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_close',\n        level: --state.level\n      });\n    }\n  }\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n}\n\n// Process ~subscript~\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\nfunction sub(state, silent) {\n  var found,\n    content,\n    max = state.posMax,\n    start = state.pos;\n  if (state.src.charCodeAt(start) !== 0x7E /* ~ */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n  if (start + 2 >= max) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  state.pos = start + 1;\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E /* ~ */) {\n      found = true;\n      break;\n    }\n    state.parser.skipToken(state);\n  }\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n  if (!silent) {\n    state.push({\n      type: 'sub',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process ^superscript^\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE$1 = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\nfunction sup(state, silent) {\n  var found,\n    content,\n    max = state.posMax,\n    start = state.pos;\n  if (state.src.charCodeAt(start) !== 0x5E /* ^ */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n  if (start + 2 >= max) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  state.pos = start + 1;\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E /* ^ */) {\n      found = true;\n      break;\n    }\n    state.parser.skipToken(state);\n  }\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE$1, '$1')\n    });\n  }\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process [links](<to> \"stuff\")\n\nfunction links(state, silent) {\n  var labelStart,\n    labelEnd,\n    label,\n    href,\n    title,\n    pos,\n    ref,\n    code,\n    isImage = false,\n    oldPos = state.pos,\n    max = state.posMax,\n    start = state.pos,\n    marker = state.src.charCodeAt(start);\n  if (marker === 0x21 /* ! */) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n  if (marker !== 0x5B /* [ */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) {\n    return false;\n  }\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n    if (pos >= max) {\n      return false;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      }\n    } else {\n      title = '';\n    }\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n\n    // do not allow nested reference links\n    if (state.linkLevel > 0) {\n      return false;\n    }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n      label = state.src.slice(labelStart, labelEnd);\n    }\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({\n        type: 'link_close',\n        level: --state.level\n      });\n    }\n  }\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// Process inline footnotes (^[...])\n\nfunction footnote_inline(state, silent) {\n  var labelStart,\n    labelEnd,\n    footnoteId,\n    oldLength,\n    max = state.posMax,\n    start = state.pos;\n  if (start + 2 >= max) {\n    return false;\n  }\n  if (state.src.charCodeAt(start) !== 0x5E /* ^ */) {\n    return false;\n  }\n  if (state.src.charCodeAt(start + 1) !== 0x5B /* [ */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  labelStart = start + 2;\n  labelEnd = parseLinkLabel(state, start + 1);\n\n  // parser failed to find ']', so it's not a valid note\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    if (!state.env.footnotes) {\n      state.env.footnotes = {};\n    }\n    if (!state.env.footnotes.list) {\n      state.env.footnotes.list = [];\n    }\n    footnoteId = state.env.footnotes.list.length;\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      level: state.level\n    });\n    state.linkLevel++;\n    oldLength = state.tokens.length;\n    state.parser.tokenize(state);\n    state.env.footnotes.list[footnoteId] = {\n      tokens: state.tokens.splice(oldLength)\n    };\n    state.linkLevel--;\n  }\n  state.pos = labelEnd + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process footnote references ([^...])\n\nfunction footnote_ref(state, silent) {\n  var label,\n    pos,\n    footnoteId,\n    footnoteSubId,\n    max = state.posMax,\n    start = state.pos;\n\n  // should be at least 4 chars - \"[^x]\"\n  if (start + 3 > max) {\n    return false;\n  }\n  if (!state.env.footnotes || !state.env.footnotes.refs) {\n    return false;\n  }\n  if (state.src.charCodeAt(start) !== 0x5B /* [ */) {\n    return false;\n  }\n  if (state.src.charCodeAt(start + 1) !== 0x5E /* ^ */) {\n    return false;\n  }\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) {\n      return false;\n    }\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      return false;\n    }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n  if (pos === start + 2) {\n    return false;\n  } // no empty footnote labels\n  if (pos >= max) {\n    return false;\n  }\n  pos++;\n  label = state.src.slice(start + 2, pos - 1);\n  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') {\n    return false;\n  }\n  if (!silent) {\n    if (!state.env.footnotes.list) {\n      state.env.footnotes.list = [];\n    }\n    if (state.env.footnotes.refs[':' + label] < 0) {\n      footnoteId = state.env.footnotes.list.length;\n      state.env.footnotes.list[footnoteId] = {\n        label: label,\n        count: 0\n      };\n      state.env.footnotes.refs[':' + label] = footnoteId;\n    } else {\n      footnoteId = state.env.footnotes.refs[':' + label];\n    }\n    footnoteSubId = state.env.footnotes.list[footnoteId].count;\n    state.env.footnotes.list[footnoteId].count++;\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      subId: footnoteSubId,\n      level: state.level\n    });\n  }\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\nvar url_schemas = ['coap', 'doi', 'javascript', 'aaa', 'aaas', 'about', 'acap', 'cap', 'cid', 'crid', 'data', 'dav', 'dict', 'dns', 'file', 'ftp', 'geo', 'go', 'gopher', 'h323', 'http', 'https', 'iax', 'icap', 'im', 'imap', 'info', 'ipp', 'iris', 'iris.beep', 'iris.xpc', 'iris.xpcs', 'iris.lwz', 'ldap', 'mailto', 'mid', 'msrp', 'msrps', 'mtqp', 'mupdate', 'news', 'nfs', 'ni', 'nih', 'nntp', 'opaquelocktoken', 'pop', 'pres', 'rtsp', 'service', 'session', 'shttp', 'sieve', 'sip', 'sips', 'sms', 'snmp', 'soap.beep', 'soap.beeps', 'tag', 'tel', 'telnet', 'tftp', 'thismessage', 'tn3270', 'tip', 'tv', 'urn', 'vemmi', 'ws', 'wss', 'xcon', 'xcon-userid', 'xmlrpc.beep', 'xmlrpc.beeps', 'xmpp', 'z39.50r', 'z39.50s', 'adiumxtra', 'afp', 'afs', 'aim', 'apt', 'attachment', 'aw', 'beshare', 'bitcoin', 'bolo', 'callto', 'chrome', 'chrome-extension', 'com-eventbrite-attendee', 'content', 'cvs', 'dlna-playsingle', 'dlna-playcontainer', 'dtn', 'dvb', 'ed2k', 'facetime', 'feed', 'finger', 'fish', 'gg', 'git', 'gizmoproject', 'gtalk', 'hcp', 'icon', 'ipn', 'irc', 'irc6', 'ircs', 'itms', 'jar', 'jms', 'keyparc', 'lastfm', 'ldaps', 'magnet', 'maps', 'market', 'message', 'mms', 'ms-help', 'msnim', 'mumble', 'mvn', 'notes', 'oid', 'palm', 'paparazzi', 'platform', 'proxy', 'psyc', 'query', 'res', 'resource', 'rmi', 'rsync', 'rtmp', 'secondlife', 'sftp', 'sgn', 'skype', 'smb', 'soldat', 'spotify', 'ssh', 'steam', 'svn', 'teamspeak', 'things', 'udp', 'unreal', 'ut2004', 'ventrilo', 'view-source', 'webcal', 'wtai', 'wyciwyg', 'xfire', 'xri', 'ymsgr'];\n\n// Process autolinks '<protocol:...>'\n\n/*eslint max-len:0*/\nvar EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\nfunction autolink(state, silent) {\n  var tail,\n    linkMatch,\n    emailMatch,\n    url,\n    fullUrl,\n    pos = state.pos;\n  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {\n    return false;\n  }\n  tail = state.src.slice(pos);\n  if (tail.indexOf('>') < 0) {\n    return false;\n  }\n  linkMatch = tail.match(AUTOLINK_RE);\n  if (linkMatch) {\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {\n      return false;\n    }\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = normalizeLink(url);\n    if (!state.parser.validateLink(url)) {\n      return false;\n    }\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({\n        type: 'link_close',\n        level: state.level\n      });\n    }\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n  emailMatch = tail.match(EMAIL_RE);\n  if (emailMatch) {\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = normalizeLink('mailto:' + url);\n    if (!state.parser.validateLink(fullUrl)) {\n      return false;\n    }\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({\n        type: 'link_close',\n        level: state.level\n      });\n    }\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n  return false;\n}\n\n// Regexps to match html elements\n\nfunction replace$1(regex, options) {\n  regex = regex.source;\n  options = options || '';\n  return function self(name, val) {\n    if (!name) {\n      return new RegExp(regex, options);\n    }\n    val = val.source || val;\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\nvar attr_name = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\nvar unquoted = /[^\"'=<>`\\x00-\\x20]+/;\nvar single_quoted = /'[^']*'/;\nvar double_quoted = /\"[^\"]*\"/;\n\n/*eslint no-spaced-func:0*/\nvar attr_value = replace$1(/(?:unquoted|single_quoted|double_quoted)/)('unquoted', unquoted)('single_quoted', single_quoted)('double_quoted', double_quoted)();\nvar attribute = replace$1(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)('attr_name', attr_name)('attr_value', attr_value)();\nvar open_tag = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)('attribute', attribute)();\nvar close_tag = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\nvar comment = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar processing = /<[?].*?[?]>/;\nvar declaration = /<![A-Z]+\\s+[^>]*>/;\nvar cdata = /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/;\nvar HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)('open_tag', open_tag)('close_tag', close_tag)('comment', comment)('processing', processing)('declaration', declaration)('cdata', cdata)();\n\n// Process html tags\n\nfunction isLetter$2(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;\n}\nfunction htmltag(state, silent) {\n  var ch,\n    match,\n    max,\n    pos = state.pos;\n  if (!state.options.html) {\n    return false;\n  }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter$2(ch)) {\n    return false;\n  }\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) {\n    return false;\n  }\n  if (!silent) {\n    state.push({\n      type: 'htmltag',\n      content: state.src.slice(pos, pos + match[0].length),\n      level: state.level\n    });\n  }\n  state.pos += match[0].length;\n  return true;\n}\n\n// Process html entity - &#123;, &#xAF;, &quot;, ...\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\nfunction entity(state, silent) {\n  var ch,\n    code,\n    match,\n    pos = state.pos,\n    max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {\n    return false;\n  }\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        var decoded = decodeEntity(match[1]);\n        if (match[1] !== decoded) {\n          if (!silent) {\n            state.pending += decoded;\n          }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n  if (!silent) {\n    state.pending += '&';\n  }\n  state.pos++;\n  return true;\n}\n\n/**\n * Inline Parser `rules`\n */\n\nvar _rules$2 = [['text', text], ['newline', newline], ['escape', escape], ['backticks', backticks], ['del', del], ['ins', ins], ['mark', mark], ['emphasis', emphasis], ['sub', sub], ['sup', sup], ['links', links], ['footnote_inline', footnote_inline], ['footnote_ref', footnote_ref], ['autolink', autolink], ['htmltag', htmltag], ['entity', entity]];\n\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  }\n\n  // Can be overridden with a custom validator\n  this.validateLink = validateLink;\n}\n\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n      if (ok) {\n        break;\n      }\n    }\n    if (ok) {\n      if (state.pos >= end) {\n        break;\n      }\n      continue;\n    }\n    state.pending += state.src[state.pos++];\n  }\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = ['vbscript', 'javascript', 'file', 'data'];\n  var str = url.trim().toLowerCase();\n  // Care about digital entities \"javascript&#x3A;alert(1)\"\n  str = replaceEntities(str);\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n  return true;\n}\n\n// Remarkable default options\n\nvar defaultConfig = {\n  options: {\n    html: false,\n    // Enable HTML tags in source\n    xhtmlOut: false,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n  },\n  components: {\n    core: {\n      rules: ['block', 'inline', 'references', 'replacements', 'smartquotes', 'references', 'abbr2', 'footnote_tail']\n    },\n    block: {\n      rules: ['blockquote', 'code', 'fences', 'footnote', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph', 'table']\n    },\n    inline: {\n      rules: ['autolink', 'backticks', 'del', 'emphasis', 'entity', 'escape', 'footnote_ref', 'htmltag', 'links', 'newline', 'text']\n    }\n  }\n};\n\n// Remarkable default options\n\nvar fullConfig = {\n  options: {\n    html: false,\n    // Enable HTML tags in source\n    xhtmlOut: false,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n  },\n  components: {\n    // Don't restrict core/block/inline rules\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n// Commonmark default options\n\nvar commonmarkConfig = {\n  options: {\n    html: true,\n    // Enable HTML tags in source\n    xhtmlOut: true,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n  },\n  components: {\n    core: {\n      rules: ['block', 'inline', 'references', 'abbr2']\n    },\n    block: {\n      rules: ['blockquote', 'code', 'fences', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph']\n    },\n    inline: {\n      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'htmltag', 'links', 'newline', 'text']\n    }\n  }\n};\n\n/**\n * Preset configs\n */\n\nvar config = {\n  'default': defaultConfig,\n  'full': fullConfig,\n  'commonmark': commonmarkConfig\n};\n\n/**\n * The `StateCore` class manages state.\n *\n * @param {Object} `instance` Remarkable instance\n * @param {String} `str` Markdown string\n * @param {Object} `env`\n */\n\nfunction StateCore(instance, str, env) {\n  this.src = str;\n  this.env = env;\n  this.options = instance.options;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.inline = instance.inline;\n  this.block = instance.block;\n  this.renderer = instance.renderer;\n  this.typographer = instance.typographer;\n}\n\n/**\n * The main `Remarkable` class. Create an instance of\n * `Remarkable` with a `preset` and/or `options`.\n *\n * @param {String} `preset` If no preset is given, `default` is used.\n * @param {Object} `options`\n */\n\nfunction Remarkable(preset, options) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = 'default';\n  }\n  if (options && options.linkify != null) {\n    console.warn('linkify option is removed. Use linkify plugin instead:\\n\\n' + 'import Remarkable from \\'remarkable\\';\\n' + 'import linkify from \\'remarkable/linkify\\';\\n' + 'new Remarkable().use(linkify)\\n');\n  }\n  this.inline = new ParserInline();\n  this.block = new ParserBlock();\n  this.core = new Core();\n  this.renderer = new Renderer();\n  this.ruler = new Ruler();\n  this.options = {};\n  this.configure(config[preset]);\n  this.set(options || {});\n}\n\n/**\n * Set options as an alternative to passing them\n * to the constructor.\n *\n * ```js\n * md.set({typographer: true});\n * ```\n * @param {Object} `options`\n * @api public\n */\n\nRemarkable.prototype.set = function (options) {\n  assign(this.options, options);\n};\n\n/**\n * Batch loader for components rules states, and options\n *\n * @param  {Object} `presets`\n */\n\nRemarkable.prototype.configure = function (presets) {\n  var self = this;\n  if (!presets) {\n    throw new Error('Wrong `remarkable` preset, check name/content');\n  }\n  if (presets.options) {\n    self.set(presets.options);\n  }\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enable(presets.components[name].rules, true);\n      }\n    });\n  }\n};\n\n/**\n * Use a plugin.\n *\n * ```js\n * var md = new Remarkable();\n *\n * md.use(plugin1)\n *   .use(plugin2, opts)\n *   .use(plugin3);\n * ```\n *\n * @param  {Function} `plugin`\n * @param  {Object} `options`\n * @return {Object} `Remarkable` for chaining\n */\n\nRemarkable.prototype.use = function (plugin, options) {\n  plugin(this, options);\n  return this;\n};\n\n/**\n * Parse the input `string` and return a tokens array.\n * Modifies `env` with definitions data.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parse = function (str, env) {\n  var state = new StateCore(this, str, env);\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * The main `.render()` method that does all the magic :)\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {String} Rendered HTML.\n */\n\nRemarkable.prototype.render = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(str, env), this.options, env);\n};\n\n/**\n * Parse the given content `string` as a single string.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parseInline = function (str, env) {\n  var state = new StateCore(this, str, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * Render a single content `string`, without wrapping it\n * to paragraphs\n *\n * @param  {String} `str`\n * @param  {Object} `env`\n * @return {String}\n */\n\nRemarkable.prototype.renderInline = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(str, env), this.options, env);\n};\nexport { Remarkable, utils };","map":{"version":3,"names":["textarea","decodeEntity","name","document","createElement","innerHTML","value","typeOf","obj","Object","prototype","toString","call","isString","hasOwn","hasOwnProperty","has","object","key","assign","sources","slice","arguments","forEach","source","TypeError","keys","UNESCAPE_MD_RE","unescapeMd","str","indexOf","replace","isValidEntityCode","c","fromCodePoint","surrogate1","surrogate2","String","fromCharCode","NAMED_ENTITY_RE","DIGITAL_ENTITY_TEST_RE","replaceEntityPattern","match","code","decoded","charCodeAt","test","toLowerCase","parseInt","replaceEntities","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","HTML_REPLACEMENTS","replaceUnsafeChar","ch","escapeHtml","utils","freeze","rules","blockquote_open","blockquote_close","tokens","idx","getBreak","block","content","fence","options","env","instance","token","langClass","langPrefix","langName","fences","fenceName","highlighted","params","split","join","fence_custom","highlight","apply","concat","heading_open","hLevel","heading_close","hr","xhtmlOut","bullet_list_open","bullet_list_close","list_item_open","list_item_close","ordered_list_open","order","ordered_list_close","paragraph_open","tight","paragraph_close","addBreak","type","link_open","title","target","linkTarget","href","link_close","image","src","alt","suffix","table_open","table_close","thead_open","thead_close","tbody_open","tbody_close","tr_open","tr_close","th_open","align","th_close","td_open","td_close","strong_open","strong_close","em_open","em_close","del_open","del_close","ins_open","ins_close","mark_open","mark_close","sub","sup","hardbreak","softbreak","breaks","text","htmlblock","htmltag","abbr_open","abbr_close","footnote_ref","n","Number","id","subId","footnote_block_open","footnote_block_close","footnote_open","footnote_close","footnote_anchor","dl_open","dt_open","dd_open","dl_close","dt_close","dd_close","nextToken","length","Renderer","renderInline","_rules","len","i","result","render","children","Ruler","__rules__","__cache__","__find__","__compile__","self","chains","rule","enabled","altName","push","chain","fn","at","opt","Error","before","beforeName","ruleName","splice","after","afterName","enable","list","strict","Array","isArray","disable","getRules","chainName","state","inlineMode","trim","level","lines","parse","StateInline","parserInline","outTokens","parser","pos","posMax","pending","pendingLevel","cache","isInLabel","linkLevel","linkContent","labelUnmatchedScopes","pushPending","cacheSet","val","cacheGet","parseLinkLabel","start","found","marker","labelEnd","max","oldPos","oldFlag","skipToken","parseAbbr","label","abbreviations","abbr","l","inline","normalizeLink","url","normalized","decodeURI","err","encodeURI","parseLinkDestination","link","validateLink","parseLinkTitle","normalizeReference","toUpperCase","parseReference","references","tok","footnote_block","j","t","lastParagraph","current","currentLabel","insideRef","refTokens","footnotes","filter","pop","count","PUNCT_CHARS","regEscape","s","abbr2","nodes","reg","m","regText","blockTokens","abbrRegExp","map","x","substr","sort","a","b","RegExp","lastIndex","exec","index","RARE_RE","SCOPED_ABBR_RE","SCOPED_ABBR","replaceScopedAbbr","inlineTokens","blkIdx","typographer","QUOTE_TEST_RE","QUOTE_RE","PUNCT_RE","APOSTROPHE","isLetter","replaceAt","smartquotes","thisLevel","lastSpace","nextSpace","item","canOpen","canClose","isSingle","stack","OUTER","single","quotes","Core","ruler","process","StateBlock","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","parentType","ddIndent","isEmpty","skipEmptyLines","from","skipSpaces","skipChars","skipCharsBack","min","getLines","begin","end","keepLastLF","first","last","queue","shift","Math","startLine","endLine","nextLine","silent","mem","haveEndMarker","blockquote","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","terminatorRules","terminate","maxNesting","tokenize","cnt","skipBulletListMarker","skipOrderedListMarker","markTightParagraphs","oldTight","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","footnote","oldBMark","refs","heading","tmp","lheading","next","html_blocks","HTML_TAG_OPEN_RE","HTML_TAG_CLOSE_RE","isLetter$1","lc","html","getLine","table","lineText","rows","cell","aligns","tableLines","tbodyLines","substring","skipMarker","markTightParagraphs$1","deflist","ddLine","dtLine","oldDDIndent","paragraph","_rules$1","ParserBlock","hasEmptyLines","ok","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","lineStart","lastTabPos","offset","isTerminatorChar","newline","pmax","ESCAPED","escape","backticks","matchStart","matchEnd","del","lastChar","nextChar","ins","mark","isAlphaNum","scanDelims","can_open","can_close","delims","emphasis","startCount","oldCount","newCount","res","UNESCAPE_RE","UNESCAPE_RE$1","links","labelStart","ref","isImage","footnote_inline","footnoteId","oldLength","footnoteSubId","url_schemas","EMAIL_RE","AUTOLINK_RE","autolink","tail","linkMatch","emailMatch","fullUrl","replace$1","regex","attr_name","unquoted","single_quoted","double_quoted","attr_value","attribute","open_tag","close_tag","comment","processing","declaration","cdata","HTML_TAG_RE","isLetter$2","DIGITAL_RE","NAMED_RE","entity","_rules$2","ParserInline","cached_pos","BAD_PROTOCOLS","defaultConfig","components","core","fullConfig","commonmarkConfig","config","StateCore","renderer","Remarkable","preset","linkify","console","warn","configure","set","presets","use","plugin","parseInline"],"sources":["/home/demonaarwu/projects/29th-website/node_modules/remarkable/dist/esm/index.browser.js"],"sourcesContent":["var textarea;\n\nfunction decodeEntity(name) {\n  textarea = textarea || document.createElement('textarea');\n  textarea.innerHTML = '&' + name + ';';\n  return textarea.value;\n}\n\n/**\n * Utility functions\n */\n\nfunction typeOf(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction isString(obj) {\n  return typeOf(obj) === '[object String]';\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return object\n    ? hasOwn.call(object, key)\n    : false;\n}\n\n// Extend objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = [].slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\nvar NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n  var decoded = decodeEntity(name);\n\n  if (name !== decoded) {\n    return decoded;\n  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16)\n    :\n      parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n  return match;\n}\n\nfunction replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  isString: isString,\n  has: has,\n  assign: assign,\n  unescapeMd: unescapeMd,\n  isValidEntityCode: isValidEntityCode,\n  fromCodePoint: fromCodePoint,\n  replaceEntities: replaceEntities,\n  escapeHtml: escapeHtml\n});\n\n/**\n * Renderer rules cache\n */\n\nvar rules = {};\n\n/**\n * Blockquotes\n */\n\nrules.blockquote_open = function(/* tokens, idx, options, env */) {\n  return '<blockquote>\\n';\n};\n\nrules.blockquote_close = function(tokens, idx /*, options, env */) {\n  return '</blockquote>' + getBreak(tokens, idx);\n};\n\n/**\n * Code\n */\n\nrules.code = function(tokens, idx /*, options, env */) {\n  if (tokens[idx].block) {\n    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n  }\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\n/**\n * Fenced code blocks\n */\n\nrules.fence = function(tokens, idx, options, env, instance) {\n  var token = tokens[idx];\n  var langClass = '';\n  var langPrefix = options.langPrefix;\n  var langName = '', fences, fenceName;\n  var highlighted;\n\n  if (token.params) {\n\n    //\n    // ```foo bar\n    //\n    // Try custom renderer \"foo\" first. That will simplify overwrite\n    // for diagrams, latex, and any other fenced block with custom look\n    //\n\n    fences = token.params.split(/\\s+/g);\n    fenceName = fences.join(' ');\n\n    if (has(instance.rules.fence_custom, fences[0])) {\n      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\n    }\n\n    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n    langClass = ' class=\"' + langPrefix + langName + '\"';\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))\n      || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  return '<pre><code' + langClass + '>'\n        + highlighted\n        + '</code></pre>'\n        + getBreak(tokens, idx);\n};\n\nrules.fence_custom = {};\n\n/**\n * Headings\n */\n\nrules.heading_open = function(tokens, idx /*, options, env */) {\n  return '<h' + tokens[idx].hLevel + '>';\n};\nrules.heading_close = function(tokens, idx /*, options, env */) {\n  return '</h' + tokens[idx].hLevel + '>\\n';\n};\n\n/**\n * Horizontal rules\n */\n\nrules.hr = function(tokens, idx, options /*, env */) {\n  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n};\n\n/**\n * Bullets\n */\n\nrules.bullet_list_open = function(/* tokens, idx, options, env */) {\n  return '<ul>\\n';\n};\nrules.bullet_list_close = function(tokens, idx /*, options, env */) {\n  return '</ul>' + getBreak(tokens, idx);\n};\n\n/**\n * List items\n */\n\nrules.list_item_open = function(/* tokens, idx, options, env */) {\n  return '<li>';\n};\nrules.list_item_close = function(/* tokens, idx, options, env */) {\n  return '</li>\\n';\n};\n\n/**\n * Ordered list items\n */\n\nrules.ordered_list_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n  return '<ol' + order + '>\\n';\n};\nrules.ordered_list_close = function(tokens, idx /*, options, env */) {\n  return '</ol>' + getBreak(tokens, idx);\n};\n\n/**\n * Paragraphs\n */\n\nrules.paragraph_open = function(tokens, idx /*, options, env */) {\n  return tokens[idx].tight ? '' : '<p>';\n};\nrules.paragraph_close = function(tokens, idx /*, options, env */) {\n  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n};\n\n/**\n * Links\n */\n\nrules.link_open = function(tokens, idx, options /* env */) {\n  var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n  var target = options.linkTarget ? (' target=\"' + options.linkTarget + '\"') : '';\n  return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n};\nrules.link_close = function(/* tokens, idx, options, env */) {\n  return '</a>';\n};\n\n/**\n * Images\n */\n\nrules.image = function(tokens, idx, options /*, env */) {\n  var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n  var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n  var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '\"';\n  var suffix = options.xhtmlOut ? ' /' : '';\n  return '<img' + src + alt + title + suffix + '>';\n};\n\n/**\n * Tables\n */\n\nrules.table_open = function(/* tokens, idx, options, env */) {\n  return '<table>\\n';\n};\nrules.table_close = function(/* tokens, idx, options, env */) {\n  return '</table>\\n';\n};\nrules.thead_open = function(/* tokens, idx, options, env */) {\n  return '<thead>\\n';\n};\nrules.thead_close = function(/* tokens, idx, options, env */) {\n  return '</thead>\\n';\n};\nrules.tbody_open = function(/* tokens, idx, options, env */) {\n  return '<tbody>\\n';\n};\nrules.tbody_close = function(/* tokens, idx, options, env */) {\n  return '</tbody>\\n';\n};\nrules.tr_open = function(/* tokens, idx, options, env */) {\n  return '<tr>';\n};\nrules.tr_close = function(/* tokens, idx, options, env */) {\n  return '</tr>\\n';\n};\nrules.th_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<th'\n    + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n    + '>';\n};\nrules.th_close = function(/* tokens, idx, options, env */) {\n  return '</th>';\n};\nrules.td_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<td'\n    + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n    + '>';\n};\nrules.td_close = function(/* tokens, idx, options, env */) {\n  return '</td>';\n};\n\n/**\n * Bold\n */\n\nrules.strong_open = function(/* tokens, idx, options, env */) {\n  return '<strong>';\n};\nrules.strong_close = function(/* tokens, idx, options, env */) {\n  return '</strong>';\n};\n\n/**\n * Italicize\n */\n\nrules.em_open = function(/* tokens, idx, options, env */) {\n  return '<em>';\n};\nrules.em_close = function(/* tokens, idx, options, env */) {\n  return '</em>';\n};\n\n/**\n * Strikethrough\n */\n\nrules.del_open = function(/* tokens, idx, options, env */) {\n  return '<del>';\n};\nrules.del_close = function(/* tokens, idx, options, env */) {\n  return '</del>';\n};\n\n/**\n * Insert\n */\n\nrules.ins_open = function(/* tokens, idx, options, env */) {\n  return '<ins>';\n};\nrules.ins_close = function(/* tokens, idx, options, env */) {\n  return '</ins>';\n};\n\n/**\n * Highlight\n */\n\nrules.mark_open = function(/* tokens, idx, options, env */) {\n  return '<mark>';\n};\nrules.mark_close = function(/* tokens, idx, options, env */) {\n  return '</mark>';\n};\n\n/**\n * Super- and sub-script\n */\n\nrules.sub = function(tokens, idx /*, options, env */) {\n  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n};\nrules.sup = function(tokens, idx /*, options, env */) {\n  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n};\n\n/**\n * Breaks\n */\n\nrules.hardbreak = function(tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\nrules.softbreak = function(tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n/**\n * Text\n */\n\nrules.text = function(tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n/**\n * Content\n */\n\nrules.htmlblock = function(tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\nrules.htmltag = function(tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * Abbreviations, initialism\n */\n\nrules.abbr_open = function(tokens, idx /*, options, env */) {\n  return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n};\nrules.abbr_close = function(/* tokens, idx, options, env */) {\n  return '</abbr>';\n};\n\n/**\n * Footnotes\n */\n\nrules.footnote_ref = function(tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n};\nrules.footnote_block_open = function(tokens, idx, options) {\n  var hr = options.xhtmlOut\n    ? '<hr class=\"footnotes-sep\" />\\n'\n    : '<hr class=\"footnotes-sep\">\\n';\n  return hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n};\nrules.footnote_block_close = function() {\n  return '</ol>\\n</section>\\n';\n};\nrules.footnote_open = function(tokens, idx) {\n  var id = Number(tokens[idx].id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n};\nrules.footnote_close = function() {\n  return '</li>\\n';\n};\nrules.footnote_anchor = function(tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n};\n\n/**\n * Definition lists\n */\n\nrules.dl_open = function() {\n  return '<dl>\\n';\n};\nrules.dt_open = function() {\n  return '<dt>';\n};\nrules.dd_open = function() {\n  return '<dd>';\n};\nrules.dl_close = function() {\n  return '</dl>\\n';\n};\nrules.dt_close = function() {\n  return '</dt>\\n';\n};\nrules.dd_close = function() {\n  return '</dd>\\n';\n};\n\n/**\n * Helper functions\n */\n\nfunction nextToken(tokens, idx) {\n  if (++idx >= tokens.length - 2) {\n    return idx;\n  }\n  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&\n      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&\n      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {\n    return nextToken(tokens, idx + 2);\n  }\n  return idx;\n}\n\n/**\n * Check to see if `\\n` is needed before the next token.\n *\n * @param  {Array} `tokens`\n * @param  {Number} `idx`\n * @return {String} Empty string or newline\n * @api private\n */\n\nvar getBreak = rules.getBreak = function getBreak(tokens, idx) {\n  idx = nextToken(tokens, idx);\n  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n    return '';\n  }\n  return '\\n';\n};\n\n/**\n * Renderer class. Renders HTML and exposes `rules` to allow\n * local modifications.\n */\n\nfunction Renderer() {\n  this.rules = assign({}, rules);\n\n  // exported helper, for custom rules only\n  this.getBreak = rules.getBreak;\n}\n\n/**\n * Render a string of inline HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length, i = 0;\n  var result = '';\n\n  while (len--) {\n    result += _rules[tokens[i].type](tokens, i++, options, env, this);\n  }\n\n  return result;\n};\n\n/**\n * Render a string of HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length, i = -1;\n  var result = '';\n\n  while (++i < len) {\n    if (tokens[i].type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else {\n      result += _rules[tokens[i].type](tokens, i, options, env, this);\n    }\n  }\n  return result;\n};\n\n/**\n * Ruler is a helper class for building responsibility chains from\n * parse rules. It allows:\n *\n *   - easy stack rules chains\n *   - getting main chain and named chains content (as arrays of functions)\n *\n * Helper methods, should not be used directly.\n * @api private\n */\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // { name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ] }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - digital anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n/**\n * Find the index of a rule by `name`.\n *\n * @param  {String} `name`\n * @return {Number} Index of the given `name`\n * @api private\n */\n\nRuler.prototype.__find__ = function (name) {\n  var len = this.__rules__.length;\n  var i = -1;\n\n  while (len--) {\n    if (this.__rules__[++i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Build the rules lookup cache\n *\n * @api private\n */\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n/**\n * Ruler public methods\n * ------------------------------------------------\n */\n\n/**\n * Replace rule function\n *\n * @param  {String} `name` Rule name\n * @param  {Function `fn`\n * @param  {Object} `options`\n * @api private\n */\n\nRuler.prototype.at = function (name, fn, options) {\n  var idx = this.__find__(name);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n\n  this.__rules__[idx].fn = fn;\n  this.__rules__[idx].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain before given the `ruleName`.\n *\n * @param  {String}   `beforeName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var idx = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n\n  this.__rules__.splice(idx, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain after the given `ruleName`.\n *\n * @param  {String}   `afterName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var idx = this.__find__(afterName);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n\n  this.__rules__.splice(idx + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the end of chain.\n *\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @return {String}\n */\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Enable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to enable\n * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n * @api private\n */\n\nRuler.prototype.enable = function (list, strict) {\n  list = !Array.isArray(list)\n    ? [ list ]\n    : list;\n\n  // In strict mode disable all existing rules first\n  if (strict) {\n    this.__rules__.forEach(function (rule) {\n      rule.enabled = false;\n    });\n  }\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n  }, this);\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Disable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to disable\n * @api private\n */\n\nRuler.prototype.disable = function (list) {\n  list = !Array.isArray(list)\n    ? [ list ]\n    : list;\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n  }, this);\n\n  this.__cache__ = null;\n};\n\n/**\n * Get a rules list as an array of functions.\n *\n * @param  {String} `chainName`\n * @return {Object}\n * @api private\n */\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n  return this.__cache__[chainName] || [];\n};\n\nfunction block(state) {\n\n  if (state.inlineMode) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.replace(/\\n/g, ' ').trim(),\n      level: 0,\n      lines: [ 0, 1 ],\n      children: []\n    });\n\n  } else {\n    state.block.parse(state.src, state.options, state.env, state.tokens);\n  }\n}\n\n// Inline parser state\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n                          // \"paired\" rules (emphasis, strikes) to not skip\n                          // tailing `]`\n\n  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent\n                          // nesting in definitions\n\n  this.linkContent = '';  // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n                                 // (backtrack optimization)\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n};\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n};\n\n// Get cache value\n//\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\nfunction parseLinkLabel(state, start) {\n  var level, found, marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) { return -1; }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5B /* [ */) {\n      level++;\n    } else if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n\n  return labelEnd;\n}\n\n// Parse abbreviation definitions, i.e. `*[abbr]: description`\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }\n  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // abbr title is always one line, so looking for ending \"\\n\" here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) { break; }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n  if (title.length === 0) { return -1; }\n  if (!env.abbreviations) { env.abbreviations = {}; }\n  // prepend ':' to avoid conflict with Object.prototype members\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nfunction abbr(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Parse inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i].type === 'inline' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction normalizeLink(url) {\n  var normalized = replaceEntities(url);\n  // We shouldn't care about the result of malformed URIs,\n  // and should not throw an exception.\n  try {\n    normalized = decodeURI(normalized);\n  } catch (err) {}\n  return encodeURI(normalized);\n}\n\n/**\n * Parse link destination\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkDestination(state, pos) {\n  var code, level, link,\n      start = pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = state.src.charCodeAt(pos);\n      if (code === 0x0A /* \\n */) { return false; }\n      if (code === 0x3E /* > */) {\n        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n        if (!state.parser.validateLink(link)) { return false; }\n        state.pos = pos + 1;\n        state.linkContent = link;\n        return true;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return false;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control chars\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n      if (level > 1) { break; }\n    }\n\n    if (code === 0x29 /* ) */) {\n      level--;\n      if (level < 0) { break; }\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return false; }\n\n  link = unescapeMd(state.src.slice(start, pos));\n  if (!state.parser.validateLink(link)) { return false; }\n\n  state.linkContent = link;\n  state.pos = pos;\n  return true;\n}\n\n/**\n * Parse link title\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkTitle(state, pos) {\n  var code,\n      start = pos,\n      max = state.posMax,\n      marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n    if (code === marker) {\n      state.pos = pos + 1;\n      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n      return true;\n    }\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    pos++;\n  }\n\n  return false;\n}\n\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  if (!parseLinkDestination(state, pos)) { return -1; }\n  href = state.linkContent;\n  pos = state.pos;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  }\n\n  // ensure that the end of the line is empty\n  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = { title: title, href: href };\n  }\n\n  return pos;\n}\n\n\nfunction references(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Scan definitions in paragraph inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' &&\n        tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.inline.parse(tok.content, state.options, state.env, tok.children);\n    }\n  }\n}\n\nfunction footnote_block(state) {\n  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,\n      level = 0,\n      insideRef = false,\n      refTokens = {};\n\n  if (!state.env.footnotes) { return; }\n\n  state.tokens = state.tokens.filter(function(tok) {\n    if (tok.type === 'footnote_reference_open') {\n      insideRef = true;\n      current = [];\n      currentLabel = tok.label;\n      return false;\n    }\n    if (tok.type === 'footnote_reference_close') {\n      insideRef = false;\n      // prepend ':' to avoid conflict with Object.prototype members\n      refTokens[':' + currentLabel] = current;\n      return false;\n    }\n    if (insideRef) { current.push(tok); }\n    return !insideRef;\n  });\n\n  if (!state.env.footnotes.list) { return; }\n  list = state.env.footnotes.list;\n\n  state.tokens.push({\n    type: 'footnote_block_open',\n    level: level++\n  });\n  for (i = 0, l = list.length; i < l; i++) {\n    state.tokens.push({\n      type: 'footnote_open',\n      id: i,\n      level: level++\n    });\n\n    if (list[i].tokens) {\n      tokens = [];\n      tokens.push({\n        type: 'paragraph_open',\n        tight: false,\n        level: level++\n      });\n      tokens.push({\n        type: 'inline',\n        content: '',\n        level: level,\n        children: list[i].tokens\n      });\n      tokens.push({\n        type: 'paragraph_close',\n        tight: false,\n        level: --level\n      });\n    } else if (list[i].label) {\n      tokens = refTokens[':' + list[i].label];\n    }\n\n    state.tokens = state.tokens.concat(tokens);\n    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n      lastParagraph = state.tokens.pop();\n    } else {\n      lastParagraph = null;\n    }\n\n    t = list[i].count > 0 ? list[i].count : 1;\n    for (j = 0; j < t; j++) {\n      state.tokens.push({\n        type: 'footnote_anchor',\n        id: i,\n        subId: j,\n        level: level\n      });\n    }\n\n    if (lastParagraph) {\n      state.tokens.push(lastParagraph);\n    }\n\n    state.tokens.push({\n      type: 'footnote_close',\n      level: --level\n    });\n  }\n  state.tokens.push({\n    type: 'footnote_block_close',\n    level: --level\n  });\n}\n\n// Enclose abbreviations in <abbr> tags\n//\n\nvar PUNCT_CHARS = ' \\n()[]\\'\".,!?-';\n\n\n// from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\nfunction regEscape(s) {\n  return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n}\n\n\nfunction abbr2(state) {\n  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,\n      blockTokens = state.tokens;\n\n  if (!state.env.abbreviations) { return; }\n  if (!state.env.abbrRegExp) {\n    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'\n            + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n                      return x.substr(1);\n                    }).sort(function (a, b) {\n                      return b.length - a.length;\n                    }).map(regEscape).join('|') + ')'\n            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n    state.env.abbrRegExp = new RegExp(regText, 'g');\n  }\n  reg = state.env.abbrRegExp;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    // We scan from the end, to keep position when new tags added.\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n      if (token.type !== 'text') { continue; }\n\n      pos = 0;\n      text = token.content;\n      reg.lastIndex = 0;\n      level = token.level;\n      nodes = [];\n\n      while ((m = reg.exec(text))) {\n        if (reg.lastIndex > pos) {\n          nodes.push({\n            type: 'text',\n            content: text.slice(pos, m.index + m[1].length),\n            level: level\n          });\n        }\n\n        nodes.push({\n          type: 'abbr_open',\n          title: state.env.abbreviations[':' + m[2]],\n          level: level++\n        });\n        nodes.push({\n          type: 'text',\n          content: m[2],\n          level: level\n        });\n        nodes.push({\n          type: 'abbr_close',\n          level: --level\n        });\n        pos = reg.lastIndex - m[3].length;\n      }\n\n      if (!nodes.length) { continue; }\n\n      if (pos < text.length) {\n        nodes.push({\n          type: 'text',\n          content: text.slice(pos),\n          level: level\n        });\n      }\n\n      // replace current node\n      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n    }\n  }\n}\n\n// Simple typographical replacements\n//\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '©',\n  'r': '®',\n  'p': '§',\n  'tm': '™'\n};\n\nfunction replaceScopedAbbr(str) {\n  if (str.indexOf('(') < 0) { return str; }\n\n  return str.replace(SCOPED_ABBR_RE, function(match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  });\n}\n\n\nfunction replace(state) {\n  var i, token, text, inlineTokens, blkIdx;\n\n  if (!state.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    inlineTokens = state.tokens[blkIdx].children;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n      if (token.type === 'text') {\n        text = token.content;\n\n        text = replaceScopedAbbr(text);\n\n        if (RARE_RE.test(text)) {\n          text = text\n            .replace(/\\+-/g, '±')\n            // .., ..., ....... -> …\n            // but ?..... & !..... -> ?.. & !..\n            .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n            // em-dash\n            .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n            // en-dash\n            .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n            .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n        }\n\n        token.content = text;\n      }\n    }\n  }\n}\n\n// Convert straight quotation marks to typographic ones\n//\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar PUNCT_RE = /[-\\s()\\[\\]]/;\nvar APOSTROPHE = '’';\n\n// This function returns true if the character at `pos`\n// could be inside a word.\nfunction isLetter(str, pos) {\n  if (pos < 0 || pos >= str.length) { return false; }\n  return !PUNCT_RE.test(str[pos]);\n}\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\n\nfunction smartquotes(state) {\n  /*eslint max-depth:0*/\n  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,\n      canOpen, canClose, j, isSingle, blkIdx, tokens,\n      stack;\n\n  if (!state.options.typographer) { return; }\n\n  stack = [];\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    tokens = state.tokens[blkIdx].children;\n    stack.length = 0;\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n\n      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }\n\n      thisLevel = tokens[i].level;\n\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) { break; }\n      }\n      stack.length = j + 1;\n\n      text = token.content;\n      pos = 0;\n      max = text.length;\n\n      /*eslint no-labels:0,block-scoped-var:0*/\n      OUTER:\n      while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n        if (!t) { break; }\n\n        lastSpace = !isLetter(text, t.index - 1);\n        pos = t.index + 1;\n        isSingle = (t[0] === \"'\");\n        nextSpace = !isLetter(text, pos);\n\n        if (!nextSpace && !lastSpace) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n          continue;\n        }\n\n        canOpen = !nextSpace;\n        canClose = !lastSpace;\n\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n            if (stack[j].level < thisLevel) { break; }\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n              if (isSingle) {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n              } else {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n              }\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Core parser `rules`\n */\n\nvar _rules = [\n  [ 'block',          block          ],\n  [ 'abbr',           abbr           ],\n  [ 'references',     references     ],\n  [ 'inline',         inline         ],\n  [ 'footnote_tail',  footnote_block  ],\n  [ 'abbr2',          abbr2          ],\n  [ 'replacements',   replace   ],\n  [ 'smartquotes',    smartquotes    ],\n];\n\n/**\n * Class for top level (`core`) parser rules\n *\n * @api private\n */\n\nfunction Core() {\n  this.options = {};\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n/**\n * Process rules with the given `state`\n *\n * @param  {Object} `state`\n * @api private\n */\n\nCore.prototype.process = function (state) {\n  var i, l, rules;\n  rules = this.ruler.getRules('');\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\n// Parser state class\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n\n  this.src = src;\n\n  // Shortcuts to simplify nested calls\n  this.parser = parser;\n\n  this.options = options;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // indent for each line\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20/* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, first, last, queue, shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) { shift = indent; }\n    if (shift < 0) { shift = 0; }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n// Code block (4 spaces padded)\n\nfunction code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last;\n\n  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'code',\n    content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n    block: true,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// fences (``` lang, ~~~ lang)\n\nfunction fences(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.tShift[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// Block quotes\n\nfunction blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n      terminatorRules,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n}\n\n// Horizontal rule\n\nfunction hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine];\n\n  pos += state.tShift[startLine];\n\n  if (pos > max) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 one\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && ch !== 0x20/* space */) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'hr',\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// Lists\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) { return -1; }\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\n\nfunction list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i, l, terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n  }\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n    if (indentAfterMarker < 1) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\n\n    // Run subparser & write tokens\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n\n    state.parser.tokenize(state, startLine, endLine, true);\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n}\n\n// Process footnote reference list\n\nfunction footnote(state, startLine, endLine, silent) {\n  var oldBMark, oldTShift, oldParentType, pos, label,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // line should be at least 5 chars - \"[^x]:\"\n  if (start + 4 > max) { return false; }\n\n  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) { return false; }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n\n  if (pos === start + 2) { return false; } // no empty footnote labels\n  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n  if (silent) { return true; }\n  pos++;\n\n  if (!state.env.footnotes) { state.env.footnotes = {}; }\n  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n  label = state.src.slice(start + 2, pos - 2);\n  state.env.footnotes.refs[':' + label] = -1;\n\n  state.tokens.push({\n    type: 'footnote_reference_open',\n    label: label,\n    level: state.level++\n  });\n\n  oldBMark = state.bMarks[startLine];\n  oldTShift = state.tShift[startLine];\n  oldParentType = state.parentType;\n  state.tShift[startLine] = state.skipSpaces(pos) - pos;\n  state.bMarks[startLine] = pos;\n  state.blkIndent += 4;\n  state.parentType = 'footnote';\n\n  if (state.tShift[startLine] < state.blkIndent) {\n    state.tShift[startLine] += state.blkIndent;\n    state.bMarks[startLine] -= state.blkIndent;\n  }\n\n  state.parser.tokenize(state, startLine, endLine, true);\n\n  state.parentType = oldParentType;\n  state.blkIndent -= 4;\n  state.tShift[startLine] = oldTShift;\n  state.bMarks[startLine] = oldBMark;\n\n  state.tokens.push({\n    type: 'footnote_reference_close',\n    level: --state.level\n  });\n\n  return true;\n}\n\n// heading (#, ##, ...)\n\nfunction heading(state, startLine, endLine, silent) {\n  var ch, level, tmp,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos >= max) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipCharsBack(max, 0x20, pos); // space\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  state.tokens.push({ type: 'heading_open',\n    hLevel: level,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  // only if header is not empty\n  if (pos < max) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.slice(pos, max).trim(),\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n  }\n  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });\n\n  return true;\n}\n\n// lheading (---, ===)\n\nfunction lheading(state, startLine, endLine/*, silent*/) {\n  var marker, pos, max,\n      next = startLine + 1;\n\n  if (next >= endLine) { return false; }\n  if (state.tShift[next] < state.blkIndent) { return false; }\n\n  // Scan next line\n\n  if (state.tShift[next] - state.blkIndent > 3) { return false; }\n\n  pos = state.bMarks[next] + state.tShift[next];\n  max = state.eMarks[next];\n\n  if (pos >= max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }\n\n  pos = state.skipChars(pos, marker);\n\n  pos = state.skipSpaces(pos);\n\n  if (pos < max) { return false; }\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n\n  state.line = next + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: marker === 0x3D/* = */ ? 1 : 2,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n  state.tokens.push({\n    type: 'inline',\n    content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n    level: state.level + 1,\n    lines: [ startLine, state.line - 1 ],\n    children: []\n  });\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: marker === 0x3D/* = */ ? 1 : 2,\n    level: state.level\n  });\n\n  return true;\n}\n\n// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\nvar html_blocks = {};\n\n[\n  'article',\n  'aside',\n  'button',\n  'blockquote',\n  'body',\n  'canvas',\n  'caption',\n  'col',\n  'colgroup',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'iframe',\n  'li',\n  'map',\n  'object',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'progress',\n  'script',\n  'section',\n  'style',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'tr',\n  'thead',\n  'ul',\n  'video'\n].forEach(function (name) { html_blocks[name] = true; });\n\n// HTML block\n\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter$1(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\nfunction htmlblock(state, startLine, endLine, silent) {\n  var ch, match, nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n\n  pos += shift;\n\n  if (!state.options.html) { return false; }\n\n  if (shift > 3 || pos + 2 >= max) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {\n    // Directive start / comment start / processing instruction start\n    if (silent) { return true; }\n\n  } else if (ch === 0x2F/* / */ || isLetter$1(ch)) {\n\n    // Probably start or end of tag\n    if (ch === 0x2F/* \\ */) {\n      // closing tag\n      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n      if (!match) { return false; }\n    } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n      if (!match) { return false; }\n    }\n    // Make sure tag name is valid\n    if (html_blocks[match[1].toLowerCase()] !== true) { return false; }\n    if (silent) { return true; }\n\n  } else {\n    return false;\n  }\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n  nextLine = startLine + 1;\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [ startLine, state.line ],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n\n  return true;\n}\n\n// GFM table, non-standard\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell,\n      aligns, t, tableLines, tbodyLines;\n\n  // should have at least three lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n\n  // first character of the second line should be '|' or '-'\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  lineText = getLine(state, startLine + 1);\n  if (!/^[-:| ]+$/.test(lineText)) { return false; }\n\n  rows = lineText.split('|');\n  if (rows <= 2) { return false; }\n  aligns = [];\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n  if (aligns.length !== rows.length) { return false; }\n  if (silent) { return true; }\n\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [ startLine, startLine + 1 ],\n    level: state.level++\n  });\n\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [ startLine, startLine + 1 ],\n    level: state.level++\n  });\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [ startLine, startLine + 1 ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [ startLine, startLine + 1 ],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({ type: 'th_close', level: --state.level });\n  }\n  state.tokens.push({ type: 'tr_close', level: --state.level });\n  state.tokens.push({ type: 'thead_close', level: --state.level });\n\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [ startLine + 2, 0 ],\n    level: state.level++\n  });\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) { break; }\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n    state.tokens.push({ type: 'tr_open', level: state.level++ });\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });\n      // 0x7c === '|'\n      cell = rows[i].substring(\n          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,\n          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length\n      ).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({ type: 'td_close', level: --state.level });\n    }\n    state.tokens.push({ type: 'tr_close', level: --state.level });\n  }\n  state.tokens.push({ type: 'tbody_close', level: --state.level });\n  state.tokens.push({ type: 'table_close', level: --state.level });\n\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n}\n\n// Definition lists\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos, marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) { return -1; }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) { return -1; }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) { return -1; }\n\n  return pos;\n}\n\nfunction markTightParagraphs$1(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction deflist(state, startLine, endLine, silent) {\n  var contentStart,\n      ddLine,\n      dtLine,\n      itemLines,\n      listLines,\n      listTokIdx,\n      nextLine,\n      oldIndent,\n      oldDDIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      prevEmptyEnd,\n      tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) { return false; }\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) { return false; }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [ startLine, 0 ],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER:\n  for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [ dtLine, dtLine ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [ dtLine, dtLine ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [ nextLine, 0 ],\n        level: state.level++\n      });\n\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) { break OUTER; }\n\n      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) { break; }\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) { break; }\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) { break; }\n    if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) { break; }\n    if (state.isEmpty(ddLine)) { ddLine++; }\n    if (ddLine >= endLine) { break; }\n\n    if (state.tShift[ddLine] < state.blkIndent) { break; }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) { break; }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs$1(state, listTokIdx);\n  }\n\n  return true;\n}\n\n// Paragraph\n\nfunction paragraph(state, startLine/*, endLine*/) {\n  var endLine, content, terminate, i, l,\n      nextLine = startLine + 1,\n      terminatorRules;\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\n\n      // Some tags can terminate paragraph without empty line.\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) { break; }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [ startLine, state.line ],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n}\n\n/**\n * Parser rules\n */\n\nvar _rules$1 = [\n  [ 'code',       code ],\n  [ 'fences',     fences,     [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'blockquote', blockquote, [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'hr',         hr,         [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'list',       list,       [ 'paragraph', 'blockquote' ] ],\n  [ 'footnote',   footnote,   [ 'paragraph' ] ],\n  [ 'heading',    heading,    [ 'paragraph', 'blockquote' ] ],\n  [ 'lheading',   lheading ],\n  [ 'htmlblock',  htmlblock,  [ 'paragraph', 'blockquote' ] ],\n  [ 'table',      table,      [ 'paragraph' ] ],\n  [ 'deflist',    deflist,    [ 'paragraph' ] ],\n  [ 'paragraph',  paragraph ]\n];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n      alt: (_rules$1[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE    = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state, lineStart = 0, lastTabPos = 0;\n  if (!str) { return []; }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x5C/* \\ */:\n    case 0x60/* ` */:\n    case 0x2A/* * */:\n    case 0x5F/* _ */:\n    case 0x5E/* ^ */:\n    case 0x5B/* [ */:\n    case 0x5D/* ] */:\n    case 0x21/* ! */:\n    case 0x26/* & */:\n    case 0x3C/* < */:\n    case 0x3E/* > */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x40/* @ */:\n    case 0x7E/* ~ */:\n    case 0x2B/* + */:\n    case 0x3D/* = */:\n    case 0x3A/* : */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n}\n\n// Proceess '\\n'\n\nfunction newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Strip out all trailing spaces on this line.\n        for (var i = pmax - 2; i >= 0; i--) {\n          if (state.pending.charCodeAt(i) !== 0x20) {\n            state.pending = state.pending.substring(0, i + 1);\n            break;\n          }\n        }\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push({\n          type: 'softbreak',\n          level: state.level\n        });\n      }\n\n    } else {\n      state.push({\n        type: 'softbreak',\n        level: state.level\n      });\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  state.pos = pos;\n  return true;\n}\n\n// Proceess escaped chars and hardbreaks\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nfunction escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n}\n\n// Parse backticks\n\nfunction backticks(state, silent) {\n  var start, max, marker, matchStart, matchEnd,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        state.push({\n          type: 'code',\n          content: state.src.slice(pos, matchStart)\n                              .replace(/[ \\n]+/g, ' ')\n                              .trim(),\n          block: false,\n          level: state.level\n        });\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n}\n\n// Process ~~deleted text~~\n\nfunction del(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x7E/* ~ */) { return false; }\n  if (nextChar === 0x7E/* ~ */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }\n  if (pos > start + 3) {\n    // sequence of 4+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '~~'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '~~'\n            stack++;\n          } // else {\n            //  // standalone ' ~~ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'del_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'del_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ++inserted text++\n\nfunction ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '++'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '++'\n            stack++;\n          } // else {\n            //  // standalone ' ++ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'ins_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'ins_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ==highlighted text==\n\nfunction mark(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x3D/* = */) { return false; }\n  if (nextChar === 0x3D/* = */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '=='\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '=='\n            stack++;\n          } // else {\n            //  // standalone ' == ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'mark_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'mark_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process *this* and _that_\n\nfunction isAlphaNum(code) {\n  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n         (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n  if (pos >= max) { can_open = false; }\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) { can_open = false; }\n      if (isAlphaNum(nextChar)) { can_close = false; }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nfunction emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) { state.pending += state.src.slice(start, state.pos); }\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_open', level: state.level++ });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_open', level: state.level++ });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_close', level: --state.level });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_close', level: --state.level });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n}\n\n// Process ~subscript~\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sub(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sub',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process ^superscript^\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE$1 = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE$1, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process [links](<to> \"stuff\")\n\n\nfunction links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21/* ! */) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n\n  if (marker !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (code !== 0x20 && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n\n    // do not allow nested reference links\n    if (state.linkLevel > 0) { return false; }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({ type: 'link_close', level: --state.level });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// Process inline footnotes (^[...])\n\n\nfunction footnote_inline(state, silent) {\n  var labelStart,\n      labelEnd,\n      footnoteId,\n      oldLength,\n      max = state.posMax,\n      start = state.pos;\n\n  if (start + 2 >= max) { return false; }\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 2;\n  labelEnd = parseLinkLabel(state, start + 1);\n\n  // parser failed to find ']', so it's not a valid note\n  if (labelEnd < 0) { return false; }\n\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n    footnoteId = state.env.footnotes.list.length;\n\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      level: state.level\n    });\n    state.linkLevel++;\n    oldLength = state.tokens.length;\n    state.parser.tokenize(state);\n    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };\n    state.linkLevel--;\n  }\n\n  state.pos = labelEnd + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process footnote references ([^...])\n\nfunction footnote_ref(state, silent) {\n  var label,\n      pos,\n      footnoteId,\n      footnoteSubId,\n      max = state.posMax,\n      start = state.pos;\n\n  // should be at least 4 chars - \"[^x]\"\n  if (start + 3 > max) { return false; }\n\n  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) { return false; }\n    if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n\n  if (pos === start + 2) { return false; } // no empty footnote labels\n  if (pos >= max) { return false; }\n  pos++;\n\n  label = state.src.slice(start + 2, pos - 1);\n  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n  if (!silent) {\n    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n    if (state.env.footnotes.refs[':' + label] < 0) {\n      footnoteId = state.env.footnotes.list.length;\n      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n      state.env.footnotes.refs[':' + label] = footnoteId;\n    } else {\n      footnoteId = state.env.footnotes.refs[':' + label];\n    }\n\n    footnoteSubId = state.env.footnotes.list[footnoteId].count;\n    state.env.footnotes.list[footnoteId].count++;\n\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      subId: footnoteSubId,\n      level: state.level\n    });\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\nvar url_schemas = [\n  'coap',\n  'doi',\n  'javascript',\n  'aaa',\n  'aaas',\n  'about',\n  'acap',\n  'cap',\n  'cid',\n  'crid',\n  'data',\n  'dav',\n  'dict',\n  'dns',\n  'file',\n  'ftp',\n  'geo',\n  'go',\n  'gopher',\n  'h323',\n  'http',\n  'https',\n  'iax',\n  'icap',\n  'im',\n  'imap',\n  'info',\n  'ipp',\n  'iris',\n  'iris.beep',\n  'iris.xpc',\n  'iris.xpcs',\n  'iris.lwz',\n  'ldap',\n  'mailto',\n  'mid',\n  'msrp',\n  'msrps',\n  'mtqp',\n  'mupdate',\n  'news',\n  'nfs',\n  'ni',\n  'nih',\n  'nntp',\n  'opaquelocktoken',\n  'pop',\n  'pres',\n  'rtsp',\n  'service',\n  'session',\n  'shttp',\n  'sieve',\n  'sip',\n  'sips',\n  'sms',\n  'snmp',\n  'soap.beep',\n  'soap.beeps',\n  'tag',\n  'tel',\n  'telnet',\n  'tftp',\n  'thismessage',\n  'tn3270',\n  'tip',\n  'tv',\n  'urn',\n  'vemmi',\n  'ws',\n  'wss',\n  'xcon',\n  'xcon-userid',\n  'xmlrpc.beep',\n  'xmlrpc.beeps',\n  'xmpp',\n  'z39.50r',\n  'z39.50s',\n  'adiumxtra',\n  'afp',\n  'afs',\n  'aim',\n  'apt',\n  'attachment',\n  'aw',\n  'beshare',\n  'bitcoin',\n  'bolo',\n  'callto',\n  'chrome',\n  'chrome-extension',\n  'com-eventbrite-attendee',\n  'content',\n  'cvs',\n  'dlna-playsingle',\n  'dlna-playcontainer',\n  'dtn',\n  'dvb',\n  'ed2k',\n  'facetime',\n  'feed',\n  'finger',\n  'fish',\n  'gg',\n  'git',\n  'gizmoproject',\n  'gtalk',\n  'hcp',\n  'icon',\n  'ipn',\n  'irc',\n  'irc6',\n  'ircs',\n  'itms',\n  'jar',\n  'jms',\n  'keyparc',\n  'lastfm',\n  'ldaps',\n  'magnet',\n  'maps',\n  'market',\n  'message',\n  'mms',\n  'ms-help',\n  'msnim',\n  'mumble',\n  'mvn',\n  'notes',\n  'oid',\n  'palm',\n  'paparazzi',\n  'platform',\n  'proxy',\n  'psyc',\n  'query',\n  'res',\n  'resource',\n  'rmi',\n  'rsync',\n  'rtmp',\n  'secondlife',\n  'sftp',\n  'sgn',\n  'skype',\n  'smb',\n  'soldat',\n  'spotify',\n  'ssh',\n  'steam',\n  'svn',\n  'teamspeak',\n  'things',\n  'udp',\n  'unreal',\n  'ut2004',\n  'ventrilo',\n  'view-source',\n  'webcal',\n  'wtai',\n  'wyciwyg',\n  'xfire',\n  'xri',\n  'ymsgr'\n];\n\n// Process autolinks '<protocol:...>'\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\n\n\nfunction autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  linkMatch = tail.match(AUTOLINK_RE);\n\n  if (linkMatch) {\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = normalizeLink(url);\n    if (!state.parser.validateLink(url)) { return false; }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({ type: 'link_close', level: state.level });\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  emailMatch = tail.match(EMAIL_RE);\n\n  if (emailMatch) {\n\n    url = emailMatch[0].slice(1, -1);\n\n    fullUrl = normalizeLink('mailto:' + url);\n    if (!state.parser.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({ type: 'link_close', level: state.level });\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n}\n\n// Regexps to match html elements\n\nfunction replace$1(regex, options) {\n  regex = regex.source;\n  options = options || '';\n\n  return function self(name, val) {\n    if (!name) {\n      return new RegExp(regex, options);\n    }\n    val = val.source || val;\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\n\nvar attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\n\nvar unquoted      = /[^\"'=<>`\\x00-\\x20]+/;\nvar single_quoted = /'[^']*'/;\nvar double_quoted = /\"[^\"]*\"/;\n\n/*eslint no-spaced-func:0*/\nvar attr_value  = replace$1(/(?:unquoted|single_quoted|double_quoted)/)\n                    ('unquoted', unquoted)\n                    ('single_quoted', single_quoted)\n                    ('double_quoted', double_quoted)\n                    ();\n\nvar attribute   = replace$1(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)\n                    ('attr_name', attr_name)\n                    ('attr_value', attr_value)\n                    ();\n\nvar open_tag    = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)\n                    ('attribute', attribute)\n                    ();\n\nvar close_tag   = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\nvar comment     = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar processing  = /<[?].*?[?]>/;\nvar declaration = /<![A-Z]+\\s+[^>]*>/;\nvar cdata       = /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/;\n\nvar HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)\n  ('open_tag', open_tag)\n  ('close_tag', close_tag)\n  ('comment', comment)\n  ('processing', processing)\n  ('declaration', declaration)\n  ('cdata', cdata)\n  ();\n\n// Process html tags\n\n\nfunction isLetter$2(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nfunction htmltag(state, silent) {\n  var ch, match, max, pos = state.pos;\n\n  if (!state.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter$2(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    state.push({\n      type: 'htmltag',\n      content: state.src.slice(pos, pos + match[0].length),\n      level: state.level\n    });\n  }\n  state.pos += match[0].length;\n  return true;\n}\n\n// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nfunction entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        var decoded = decodeEntity(match[1]);\n        if (match[1] !== decoded) {\n          if (!silent) { state.pending += decoded; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n}\n\n/**\n * Inline Parser `rules`\n */\n\nvar _rules$2 = [\n  [ 'text',            text ],\n  [ 'newline',         newline ],\n  [ 'escape',          escape ],\n  [ 'backticks',       backticks ],\n  [ 'del',             del ],\n  [ 'ins',             ins ],\n  [ 'mark',            mark ],\n  [ 'emphasis',        emphasis ],\n  [ 'sub',             sub ],\n  [ 'sup',             sup ],\n  [ 'links',           links ],\n  [ 'footnote_inline', footnote_inline ],\n  [ 'footnote_ref',    footnote_ref ],\n  [ 'autolink',        autolink ],\n  [ 'htmltag',         htmltag ],\n  [ 'entity',          entity ]\n];\n\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  }\n\n  // Can be overridden with a custom validator\n  this.validateLink = validateLink;\n}\n\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];\n  var str = url.trim().toLowerCase();\n  // Care about digital entities \"javascript&#x3A;alert(1)\"\n  str = replaceEntities(str);\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n  return true;\n}\n\n// Remarkable default options\n\nvar defaultConfig = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'block',\n        'inline',\n        'references',\n        'replacements',\n        'smartquotes',\n        'references',\n        'abbr2',\n        'footnote_tail'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fences',\n        'footnote',\n        'heading',\n        'hr',\n        'htmlblock',\n        'lheading',\n        'list',\n        'paragraph',\n        'table'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'del',\n        'emphasis',\n        'entity',\n        'escape',\n        'footnote_ref',\n        'htmltag',\n        'links',\n        'newline',\n        'text'\n      ]\n    }\n  }\n};\n\n// Remarkable default options\n\nvar fullConfig = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes:       '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight:     null,\n\n    maxNesting:    20            // Internal protection, recursion limit\n  },\n\n  components: {\n    // Don't restrict core/block/inline rules\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n// Commonmark default options\n\nvar commonmarkConfig = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'block',\n        'inline',\n        'references',\n        'abbr2'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fences',\n        'heading',\n        'hr',\n        'htmlblock',\n        'lheading',\n        'list',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'htmltag',\n        'links',\n        'newline',\n        'text'\n      ]\n    }\n  }\n};\n\n/**\n * Preset configs\n */\n\nvar config = {\n  'default': defaultConfig,\n  'full': fullConfig,\n  'commonmark': commonmarkConfig\n};\n\n/**\n * The `StateCore` class manages state.\n *\n * @param {Object} `instance` Remarkable instance\n * @param {String} `str` Markdown string\n * @param {Object} `env`\n */\n\nfunction StateCore(instance, str, env) {\n  this.src = str;\n  this.env = env;\n  this.options = instance.options;\n  this.tokens = [];\n  this.inlineMode = false;\n\n  this.inline = instance.inline;\n  this.block = instance.block;\n  this.renderer = instance.renderer;\n  this.typographer = instance.typographer;\n}\n\n/**\n * The main `Remarkable` class. Create an instance of\n * `Remarkable` with a `preset` and/or `options`.\n *\n * @param {String} `preset` If no preset is given, `default` is used.\n * @param {Object} `options`\n */\n\nfunction Remarkable(preset, options) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = 'default';\n  }\n\n  if (options && options.linkify != null) {\n    console.warn(\n      'linkify option is removed. Use linkify plugin instead:\\n\\n' +\n      'import Remarkable from \\'remarkable\\';\\n' +\n      'import linkify from \\'remarkable/linkify\\';\\n' +\n      'new Remarkable().use(linkify)\\n'\n    );\n  }\n\n  this.inline   = new ParserInline();\n  this.block    = new ParserBlock();\n  this.core     = new Core();\n  this.renderer = new Renderer();\n  this.ruler    = new Ruler();\n\n  this.options  = {};\n  this.configure(config[preset]);\n  this.set(options || {});\n}\n\n/**\n * Set options as an alternative to passing them\n * to the constructor.\n *\n * ```js\n * md.set({typographer: true});\n * ```\n * @param {Object} `options`\n * @api public\n */\n\nRemarkable.prototype.set = function (options) {\n  assign(this.options, options);\n};\n\n/**\n * Batch loader for components rules states, and options\n *\n * @param  {Object} `presets`\n */\n\nRemarkable.prototype.configure = function (presets) {\n  var self = this;\n\n  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }\n  if (presets.options) { self.set(presets.options); }\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enable(presets.components[name].rules, true);\n      }\n    });\n  }\n};\n\n/**\n * Use a plugin.\n *\n * ```js\n * var md = new Remarkable();\n *\n * md.use(plugin1)\n *   .use(plugin2, opts)\n *   .use(plugin3);\n * ```\n *\n * @param  {Function} `plugin`\n * @param  {Object} `options`\n * @return {Object} `Remarkable` for chaining\n */\n\nRemarkable.prototype.use = function (plugin, options) {\n  plugin(this, options);\n  return this;\n};\n\n\n/**\n * Parse the input `string` and return a tokens array.\n * Modifies `env` with definitions data.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parse = function (str, env) {\n  var state = new StateCore(this, str, env);\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * The main `.render()` method that does all the magic :)\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {String} Rendered HTML.\n */\n\nRemarkable.prototype.render = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(str, env), this.options, env);\n};\n\n/**\n * Parse the given content `string` as a single string.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parseInline = function (str, env) {\n  var state = new StateCore(this, str, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * Render a single content `string`, without wrapping it\n * to paragraphs\n *\n * @param  {String} `str`\n * @param  {Object} `env`\n * @return {String}\n */\n\nRemarkable.prototype.renderInline = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(str, env), this.options, env);\n};\n\nexport { Remarkable, utils };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}