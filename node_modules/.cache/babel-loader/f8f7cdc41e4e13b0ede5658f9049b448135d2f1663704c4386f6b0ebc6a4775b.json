{"ast":null,"code":"\"use strict\";\n\n/**\n * Plugin for Remarkable Markdown processor which transforms $..$ and $$..$$ sequences into math HTML using the\n * Katex package.\n */\nconst rkatex = (md, options) => {\n  const backslash = '\\\\';\n  const dollar = '$';\n  const opts = options || {};\n  const delimiter = opts.delimiter || dollar;\n  if (delimiter.length !== 1) {\n    throw new Error('invalid delimiter');\n  }\n  const katex = require(\"katex\");\n\n  /**\n   * Render the contents as KaTeX\n   */\n  const renderKatex = (source, displayMode) => katex.renderToString(source, {\n    displayMode: displayMode,\n    throwOnError: false\n  });\n\n  /**\n   * Parse '$$' as a block. Based off of similar method in remarkable.\n   */\n  const parseBlockKatex = (state, startLine, endLine) => {\n    let haveEndMarker = false;\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n    if (pos + 1 > max) {\n      return false;\n    }\n    const marker = state.src.charAt(pos);\n    if (marker !== delimiter) {\n      return false;\n    }\n\n    // scan marker length\n    let mem = pos;\n    pos = state.skipChars(pos, marker);\n    let len = pos - mem;\n    if (len !== 2) {\n      return false;\n    }\n\n    // search end of block\n    let nextLine = startLine;\n    for (;;) {\n      ++nextLine;\n      if (nextLine >= endLine) {\n        break;\n      }\n      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n        break;\n      }\n      if (state.src.charAt(pos) !== delimiter) {\n        continue;\n      }\n      if (state.tShift[nextLine] - state.blkIndent >= 4) {\n        continue;\n      }\n      pos = state.skipChars(pos, marker);\n      if (pos - mem < len) {\n        continue;\n      }\n      pos = state.skipSpaces(pos);\n      if (pos < max) {\n        continue;\n      }\n      haveEndMarker = true;\n      break;\n    }\n\n    // If a fence has heading spaces, they should be removed from its inner block\n    len = state.tShift[startLine];\n    state.line = nextLine + (haveEndMarker ? 1 : 0);\n    const content = state.getLines(startLine + 1, nextLine, len, true).replace(/[ \\n]+/g, ' ').trim();\n    state.tokens.push({\n      type: 'katex',\n      params: null,\n      content: content,\n      lines: [startLine, state.line],\n      level: state.level,\n      block: true\n    });\n    return true;\n  };\n\n  /**\n   * Look for '$' or '$$' spans in Markdown text. Based off of the 'fenced' parser in remarkable.\n   */\n  const parseInlineKatex = (state, silent) => {\n    const start = state.pos;\n    const max = state.posMax;\n    let pos = start;\n\n    // Unexpected starting character\n    if (state.src.charAt(pos) !== delimiter) {\n      return false;\n    }\n    ++pos;\n    while (pos < max && state.src.charAt(pos) === delimiter) {\n      ++pos;\n    }\n\n    // Capture the length of the starting delimiter -- closing one must match in size\n    const marker = state.src.slice(start, pos);\n    if (marker.length > 2) {\n      return false;\n    }\n    const spanStart = pos;\n    let escapedDepth = 0;\n    while (pos < max) {\n      const char = state.src.charAt(pos);\n      if (char === '{' && (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth += 1;\n      } else if (char === '}' && (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth -= 1;\n        if (escapedDepth < 0) {\n          return false;\n        }\n      } else if (char === delimiter && escapedDepth === 0) {\n        const matchStart = pos;\n        let matchEnd = pos + 1;\n        while (matchEnd < max && state.src.charAt(matchEnd) === delimiter) {\n          ++matchEnd;\n        }\n        if (matchEnd - matchStart === marker.length) {\n          if (!silent) {\n            const content = state.src.slice(spanStart, matchStart).replace(/[ \\n]+/g, ' ').trim();\n            state.push({\n              type: 'katex',\n              content: content,\n              block: marker.length > 1,\n              level: state.level\n            });\n          }\n          state.pos = matchEnd;\n          return true;\n        }\n      }\n      pos += 1;\n    }\n    if (!silent) {\n      state.pending += marker;\n    }\n    state.pos += marker.length;\n    return true;\n  };\n  md.inline.ruler.push('katex', parseInlineKatex, options);\n  md.block.ruler.push('katex', parseBlockKatex, options);\n  md.renderer.rules.katex = (tokens, idx) => renderKatex(tokens[idx].content, tokens[idx].block);\n  md.renderer.rules.katex.delimiter = delimiter;\n};\nmodule.exports = rkatex;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}