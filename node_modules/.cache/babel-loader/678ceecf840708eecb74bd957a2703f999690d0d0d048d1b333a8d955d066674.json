{"ast":null,"code":"\"use strict\";\n\n/**\n * Plugin for Remarkable Markdown processor which transforms $..$ and $$..$$ sequences into math HTML using the\n * Katex package.\n */\nconst rkatex = (md, options) => {\n  const backslash = '\\\\';\n  const dollar = '$';\n  const opts = options || {};\n  const delimiter = opts.delimiter || dollar;\n  if (delimiter.length !== 1) {\n    throw new Error('invalid delimiter');\n  }\n  const katex = require(\"katex\");\n\n  /**\n   * Render the contents as KaTeX\n   */\n  const renderKatex = (source, displayMode) => katex.renderToString(source, {\n    displayMode: displayMode,\n    throwOnError: false\n  });\n\n  /**\n   * Parse '$$' as a block. Based off of similar method in remarkable.\n   */\n  const parseBlockKatex = (state, startLine, endLine) => {\n    let haveEndMarker = false;\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n    if (pos + 1 > max) {\n      return false;\n    }\n    const marker = state.src.charAt(pos);\n    if (marker !== delimiter) {\n      return false;\n    }\n\n    // scan marker length\n    let mem = pos;\n    pos = state.skipChars(pos, marker);\n    let len = pos - mem;\n    if (len !== 2) {\n      return false;\n    }\n\n    // search end of block\n    let nextLine = startLine;\n    for (;;) {\n      ++nextLine;\n      if (nextLine >= endLine) {\n        break;\n      }\n      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n        break;\n      }\n      if (state.src.charAt(pos) !== delimiter) {\n        continue;\n      }\n      if (state.tShift[nextLine] - state.blkIndent >= 4) {\n        continue;\n      }\n      pos = state.skipChars(pos, marker);\n      if (pos - mem < len) {\n        continue;\n      }\n      pos = state.skipSpaces(pos);\n      if (pos < max) {\n        continue;\n      }\n      haveEndMarker = true;\n      break;\n    }\n\n    // If a fence has heading spaces, they should be removed from its inner block\n    len = state.tShift[startLine];\n    state.line = nextLine + (haveEndMarker ? 1 : 0);\n    const content = state.getLines(startLine + 1, nextLine, len, true).replace(/[ \\n]+/g, ' ').trim();\n    state.tokens.push({\n      type: 'katex',\n      params: null,\n      content: content,\n      lines: [startLine, state.line],\n      level: state.level,\n      block: true\n    });\n    return true;\n  };\n\n  /**\n   * Look for '$' or '$$' spans in Markdown text. Based off of the 'fenced' parser in remarkable.\n   */\n  const parseInlineKatex = (state, silent) => {\n    const start = state.pos;\n    const max = state.posMax;\n    let pos = start;\n\n    // Unexpected starting character\n    if (state.src.charAt(pos) !== delimiter) {\n      return false;\n    }\n    ++pos;\n    while (pos < max && state.src.charAt(pos) === delimiter) {\n      ++pos;\n    }\n\n    // Capture the length of the starting delimiter -- closing one must match in size\n    const marker = state.src.slice(start, pos);\n    if (marker.length > 2) {\n      return false;\n    }\n    const spanStart = pos;\n    let escapedDepth = 0;\n    while (pos < max) {\n      const char = state.src.charAt(pos);\n      if (char === '{' && (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth += 1;\n      } else if (char === '}' && (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth -= 1;\n        if (escapedDepth < 0) {\n          return false;\n        }\n      } else if (char === delimiter && escapedDepth === 0) {\n        const matchStart = pos;\n        let matchEnd = pos + 1;\n        while (matchEnd < max && state.src.charAt(matchEnd) === delimiter) {\n          ++matchEnd;\n        }\n        if (matchEnd - matchStart === marker.length) {\n          if (!silent) {\n            const content = state.src.slice(spanStart, matchStart).replace(/[ \\n]+/g, ' ').trim();\n            state.push({\n              type: 'katex',\n              content: content,\n              block: marker.length > 1,\n              level: state.level\n            });\n          }\n          state.pos = matchEnd;\n          return true;\n        }\n      }\n      pos += 1;\n    }\n    if (!silent) {\n      state.pending += marker;\n    }\n    state.pos += marker.length;\n    return true;\n  };\n  md.inline.ruler.push('katex', parseInlineKatex, options);\n  md.block.ruler.push('katex', parseBlockKatex, options);\n  md.renderer.rules.katex = (tokens, idx) => renderKatex(tokens[idx].content, tokens[idx].block);\n  md.renderer.rules.katex.delimiter = delimiter;\n};\nmodule.exports = rkatex;","map":{"version":3,"names":["rkatex","md","options","backslash","dollar","opts","delimiter","length","Error","katex","require","renderKatex","source","displayMode","renderToString","throwOnError","parseBlockKatex","state","startLine","endLine","haveEndMarker","pos","bMarks","tShift","max","eMarks","marker","src","charAt","mem","skipChars","len","nextLine","blkIndent","skipSpaces","line","content","getLines","replace","trim","tokens","push","type","params","lines","level","block","parseInlineKatex","silent","start","posMax","slice","spanStart","escapedDepth","char","matchStart","matchEnd","pending","inline","ruler","renderer","rules","idx","module","exports"],"sources":["/home/demonaarwu/projects/29th-website/node_modules/remarkable-katex/index.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Plugin for Remarkable Markdown processor which transforms $..$ and $$..$$ sequences into math HTML using the\n * Katex package.\n */\nconst rkatex = (md, options) => {\n  const backslash = '\\\\';\n  const dollar = '$';\n  const opts = options || {};\n  const delimiter = opts.delimiter || dollar;\n  if (delimiter.length !== 1) { throw new Error('invalid delimiter'); }\n\n  const katex = require(\"katex\");\n\n  /**\n   * Render the contents as KaTeX\n   */\n  const renderKatex = (source, displayMode) => katex.renderToString(source,\n                                                                    {displayMode: displayMode,\n                                                                     throwOnError: false});\n\n  /**\n   * Parse '$$' as a block. Based off of similar method in remarkable.\n   */\n  const parseBlockKatex = (state, startLine, endLine) => {\n    let haveEndMarker = false;\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    if (pos + 1 > max) { return false; }\n\n    const marker = state.src.charAt(pos);\n    if (marker !== delimiter) { return false; }\n\n    // scan marker length\n    let mem = pos;\n    pos = state.skipChars(pos, marker);\n    let len = pos - mem;\n\n    if (len !== 2) { return false; }\n\n    // search end of block\n    let nextLine = startLine;\n\n    for (;;) {\n      ++nextLine;\n      if (nextLine >= endLine) { break; }\n\n      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max && state.tShift[nextLine] < state.blkIndent) { break; }\n      if (state.src.charAt(pos) !== delimiter) { continue; }\n      if (state.tShift[nextLine] - state.blkIndent >= 4) { continue; }\n\n      pos = state.skipChars(pos, marker);\n      if (pos - mem < len) { continue; }\n\n      pos = state.skipSpaces(pos);\n      if (pos < max) { continue; }\n\n      haveEndMarker = true;\n      break;\n    }\n\n    // If a fence has heading spaces, they should be removed from its inner block\n    len = state.tShift[startLine];\n    state.line = nextLine + (haveEndMarker ? 1 : 0);\n    const content = state.getLines(startLine + 1, nextLine, len, true)\n            .replace(/[ \\n]+/g, ' ')\n            .trim();\n\n    state.tokens.push({type: 'katex', params: null, content: content, lines: [startLine, state.line],\n                       level: state.level, block: true});\n    return true;\n  };\n\n  /**\n   * Look for '$' or '$$' spans in Markdown text. Based off of the 'fenced' parser in remarkable.\n   */\n  const parseInlineKatex = (state, silent) => {\n    const start = state.pos;\n    const max = state.posMax;\n    let pos = start;\n\n    // Unexpected starting character\n    if (state.src.charAt(pos) !== delimiter) { return false; }\n\n    ++pos;\n    while (pos < max && state.src.charAt(pos) === delimiter) { ++pos; }\n\n    // Capture the length of the starting delimiter -- closing one must match in size\n    const marker = state.src.slice(start, pos);\n    if (marker.length > 2) { return false; }\n\n    const spanStart = pos;\n    let escapedDepth = 0;\n    while (pos < max) {\n      const char = state.src.charAt(pos);\n      if (char === '{' && (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth += 1;\n      } else if (char === '}' && (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth -= 1;\n        if (escapedDepth < 0) { return false; }\n      } else if (char === delimiter && escapedDepth === 0) {\n        const matchStart = pos;\n        let matchEnd = pos + 1;\n        while (matchEnd < max && state.src.charAt(matchEnd) === delimiter) { ++matchEnd; }\n\n        if (matchEnd - matchStart === marker.length) {\n          if (!silent) {\n            const content = state.src.slice(spanStart, matchStart)\n                .replace(/[ \\n]+/g, ' ')\n                .trim();\n            state.push({type: 'katex', content: content, block: marker.length > 1, level: state.level});\n          }\n          state.pos = matchEnd;\n          return true;\n        }\n      }\n      pos += 1;\n    }\n\n    if (!silent) { state.pending += marker; }\n    state.pos += marker.length;\n\n    return true;\n  };\n\n  md.inline.ruler.push('katex', parseInlineKatex, options);\n  md.block.ruler.push('katex', parseBlockKatex, options);\n  md.renderer.rules.katex = (tokens, idx) => renderKatex(tokens[idx].content, tokens[idx].block);\n  md.renderer.rules.katex.delimiter = delimiter;\n};\n\nmodule.exports = rkatex;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}